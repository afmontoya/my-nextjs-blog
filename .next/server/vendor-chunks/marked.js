"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked";
exports.ids = ["vendor-chunks/marked"];
exports.modules = {

/***/ "(rsc)/./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ _Hooks),\n/* harmony export */   Lexer: () => (/* binding */ _Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ _Parser),\n/* harmony export */   Renderer: () => (/* binding */ _Renderer),\n/* harmony export */   TextRenderer: () => (/* binding */ _TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ _Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ _defaults),\n/* harmony export */   getDefaults: () => (/* binding */ _getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v15.0.7 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ /**\n * Gets the original marked default options.\n */ function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\nconst noopTest = {\n    exec: ()=>null\n};\nfunction edit(regex, opt = \"\") {\n    let source = typeof regex === \"string\" ? regex : regex.source;\n    const obj = {\n        replace: (name, val)=>{\n            let valSource = typeof val === \"string\" ? val : val.source;\n            valSource = valSource.replace(other.caret, \"$1\");\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(source, opt);\n        }\n    };\n    return obj;\n}\nconst other = {\n    codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n    outputLinkReplace: /\\\\([\\[\\]])/g,\n    indentCodeCompensation: /^(\\s+)(?:```)/,\n    beginningSpace: /^\\s+/,\n    endingHash: /#$/,\n    startingSpaceChar: /^ /,\n    endingSpaceChar: / $/,\n    nonSpaceChar: /[^ ]/,\n    newLineCharGlobal: /\\n/g,\n    tabCharGlobal: /\\t/g,\n    multipleSpaceGlobal: /\\s+/g,\n    blankLine: /^[ \\t]*$/,\n    doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n    blockquoteStart: /^ {0,3}>/,\n    blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n    blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n    listReplaceTabs: /^\\t+/,\n    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n    listIsTask: /^\\[[ xX]\\] /,\n    listReplaceTask: /^\\[[ xX]\\] +/,\n    anyLine: /\\n.*\\n/,\n    hrefBrackets: /^<(.*)>$/,\n    tableDelimiter: /[:|]/,\n    tableAlignChars: /^\\||\\| *$/g,\n    tableRowBlankLine: /\\n[ \\t]*$/,\n    tableAlignRight: /^ *-+: *$/,\n    tableAlignCenter: /^ *:-+: *$/,\n    tableAlignLeft: /^ *:-+ *$/,\n    startATag: /^<a /i,\n    endATag: /^<\\/a>/i,\n    startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n    endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n    startAngleBracket: /^</,\n    endAngleBracket: />$/,\n    pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n    unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n    escapeTest: /[&<>\"']/,\n    escapeReplace: /[&<>\"']/g,\n    escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n    escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n    unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n    caret: /(^|[^\\[])\\^/g,\n    percentDecode: /%25/g,\n    findPipe: /\\|/g,\n    splitPipe: / \\|/,\n    slashPipe: /\\\\\\|/g,\n    carriageReturn: /\\r\\n|\\r/g,\n    spaceLine: /^ +$/gm,\n    notSpaceStart: /^\\S*/,\n    endingNewline: /\\n$/,\n    listItemRegex: (bull)=>new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n    nextBulletRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n    hrRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n    fencesBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n    headingBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n    htmlBeginRegex: (indent)=>new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, \"i\")\n};\n/**\n * Block-Level Grammar\n */ const newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore).replace(/bull/g, bullet) // lists can interrupt\n.replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n.replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n.replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n.replace(/\\|table/g, \"\") // table not in commonmark\n.getRegex();\nconst lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet) // lists can interrupt\n.replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n.replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n.replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n.replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n.getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\nconst _tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title\" + \"|tr|track|ul\";\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\"^ {0,3}(?:\" // optional indentation\n + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)\" // (6)\n + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)\" // (7) open tag\n + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)\" // (7) closing tag\n + \")\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nconst paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setext headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ const blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText\n};\n/**\n * GFM Block Grammar\n */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n\" // Header\n + \" {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)\" // Align\n + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n.replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \"(?: {4}| {0,3}\t)[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    lheading: lheadingGfm,\n    table: gfmTable,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setext headings don't interrupt commonmark paragraphs\n    .replace(\"table\", gfmTable) // interrupt paragraphs with table\n    .replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex()\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ const blockPedantic = {\n    ...blockNormal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ const escape$1 = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, \"u\").replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\nconst emStrongLDelim = edit(emStrongLDelimCore, \"u\").replace(/punct/g, _punctuation).getRegex();\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, \"u\").replace(/punct/g, _punctuationGfmStrongEm).getRegex();\nconst emStrongRDelimAstCore = \"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)\" // Skip orphan inside strong\n + \"|[^*]+(?=[^*])\" // Consume to delim\n + \"|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)\" // (1) #*** can only be a Right Delimiter\n + \"|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)\" // (2) a***#, a*** can only be a Right Delimiter\n + \"|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)\" // (3) #***a, ***a can only be Left Delimiter\n + \"|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)\" // (4) ***# can only be Left Delimiter\n + \"|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)\" // (5) #***# can be either Left or Right Delimiter\n + \"|notPunctSpace(\\\\*+)(?=notPunctSpace)\"; // (6) a***a can be either Left or Right Delimiter\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, \"gu\").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, \"gu\").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)\" // Skip orphan inside strong\n + \"|[^_]+(?=[^_])\" // Consume to delim\n + \"|(?!_)punct(_+)(?=[\\\\s]|$)\" // (1) #___ can only be a Right Delimiter\n + \"|notPunctSpace(_+)(?!_)(?=punctSpace|$)\" // (2) a___#, a___ can only be a Right Delimiter\n + \"|(?!_)punctSpace(_+)(?=notPunctSpace)\" // (3) #___a, ___a can only be Left Delimiter\n + \"|[\\\\s](_+)(?!_)(?=punct)\" // (4) ___# can only be Left Delimiter\n + \"|(?!_)punct(_+)(?!_)(?=punct)\", \"gu\") // (5) #___# can be either Left or Right Delimiter\n.replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex();\nconst anyPunctuation = edit(/\\\\(punct)/, \"gu\").replace(/punct/g, _punctuation).getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\nconst _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\nconst tag = edit(\"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n.replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\nconst reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ const inlineNormal = {\n    _backpedal: noopTest,\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape: escape$1,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest\n};\n/**\n * Pedantic Inline Grammar\n */ const inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ const inlineGfm = {\n    ...inlineNormal,\n    emStrongRDelimAst: emStrongRDelimAstGfm,\n    emStrongLDelim: emStrongLDelimGfm,\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */ const inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * exports\n */ const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic\n};\n/**\n * Helpers\n */ const escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (other.escapeTest.test(html)) {\n            return html.replace(other.escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (other.escapeTestNoEncode.test(html)) {\n            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(other.percentDecode, \"%\");\n    } catch  {\n        return null;\n    }\n    return href;\n}\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(other.findPipe, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(other.splitPipe);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells.at(-1)?.trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(other.slashPipe, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && true) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction outputLink(cap, link, raw, lexer, rules) {\n    const href = link.href;\n    const title = link.title || null;\n    const text = cap[1].replace(rules.other.outputLinkReplace, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text\n    };\n}\nfunction indentCodeCompensation(raw, text, rules) {\n    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(rules.other.beginningSpace);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class _Tokenizer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(this.rules.other.codeRemoveIndent, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\", this.rules);\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (this.rules.other.endingHash.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: rtrim(cap[0], \"\\n\")\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], \"\\n\").split(\"\\n\");\n            let raw = \"\";\n            let text = \"\";\n            const tokens = [];\n            while(lines.length > 0){\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for(i = 0; i < lines.length; i++){\n                    // get lines up to a continuation\n                    if (this.rules.other.blockquoteStart.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    } else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    } else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join(\"\\n\");\n                const currentText = currentRaw// precede setext continuation with 4 spaces so it isn't a setext\n                .replace(this.rules.other.blockquoteSetextReplace, \"\\n    $1\").replace(this.rules.other.blockquoteSetextReplace2, \"\");\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"code\") {\n                    break;\n                } else if (lastToken?.type === \"blockquote\") {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                } else if (lastToken?.type === \"list\") {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + \"\\n\" + lines.join(\"\\n\");\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens.at(-1).raw.length).split(\"\\n\");\n                    continue;\n                }\n            }\n            return {\n                type: \"blockquote\",\n                raw,\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = this.rules.other.listItemRegex(bull);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while(src){\n                let endEarly = false;\n                let raw = \"\";\n                let itemContents = \"\";\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(this.rules.other.listReplaceTabs, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else if (blankLine) {\n                    indent = cap[1].length + 1;\n                } else {\n                    indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && this.rules.other.blankLine.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                    const hrRegex = this.rules.other.hrRegex(indent);\n                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, \"  \");\n                            nextLineWithoutTabs = nextLine;\n                        } else {\n                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, \"    \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLineWithoutTabs.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(this.rules.other.tabCharGlobal, \"    \").search(this.rules.other.nonSpaceChar) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (this.rules.other.doubleBlankLine.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = this.rules.other.listIsTask.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            const lastItem = list.items.at(-1);\n            if (lastItem) {\n                lastItem.raw = lastItem.raw.trimEnd();\n                lastItem.text = lastItem.text.trimEnd();\n            } else {\n                // not a list since there were no items\n                return;\n            }\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(let i = 0; i < list.items.length; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>this.rules.other.anyLine.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(let i = 0; i < list.items.length; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, \" \");\n            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!this.rules.other.tableDelimiter.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(this.rules.other.tableAlignChars, \"\").split(\"|\");\n        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, \"\").split(\"\\n\") : [];\n        const item = {\n            type: \"table\",\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns){\n            if (this.rules.other.tableAlignRight.test(align)) {\n                item.align.push(\"right\");\n            } else if (this.rules.other.tableAlignCenter.test(align)) {\n                item.align.push(\"center\");\n            } else if (this.rules.other.tableAlignLeft.test(align)) {\n                item.align.push(\"left\");\n            } else {\n                item.align.push(null);\n            }\n        }\n        for(let i = 0; i < headers.length; i++){\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i]\n            });\n        }\n        for (const row of rows){\n            item.rows.push(splitCells(row, item.header.length).map((cell, i)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i]\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: cap[1]\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!this.rules.other.endAngleBracket.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = this.rules.other.pedanticHrefTitle.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (this.rules.other.startAngleBracket.test(href)) {\n                if (this.options.pedantic && !this.rules.other.endAngleBracket.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n            }, cap[0], this.lexer, this.rules);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, \" \");\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer, this.rules);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [\n                    ...match[0]\n                ][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(this.rules.other.newLineCharGlobal, \" \");\n            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = cap[1];\n                href = \"mailto:\" + text;\n            } else {\n                text = cap[1];\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = cap[0];\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n                }while (prevCapZero !== cap[0]);\n                text = cap[0];\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            const escaped = this.lexer.state.inRawBlock;\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                escaped\n            };\n        }\n    }\n}\n/**\n * Block Lexer\n */ class _Lexer {\n    constructor(options){\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            other,\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */ static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */ static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */ lex(src) {\n        src = src.replace(other.carriageReturn, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        for(let i = 0; i < this.inlineQueue.length; i++){\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(other.tabCharGlobal, \"    \").replace(other.spaceLine, \"\");\n        }\n        while(src){\n            let token;\n            if (this.options.extensions?.block?.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.raw.length === 1 && lastToken !== undefined) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    lastToken.raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken?.type === \"paragraph\" || lastToken?.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"paragraph\" || lastToken?.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                const lastToken = tokens.at(-1);\n                if (lastParagraphClipped && lastToken?.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */ inlineTokens(src, tokens = []) {\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match = null;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        let keepPrevChar = false;\n        let prevChar = \"\";\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            let token;\n            // extensions\n            if (this.options.extensions?.inline?.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.type === \"text\" && lastToken?.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class _Renderer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return \"\";\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || \"\").match(other.notSpaceStart)?.[0];\n        const code = text.replace(other.endingNewline, \"\") + \"\\n\";\n        if (!langString) {\n            return \"<pre><code>\" + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"language-' + escape(langString) + '\">' + (escaped ? code : escape(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return \"<hr>\\n\";\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = \"\";\n        for(let j = 0; j < token.items.length; j++){\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? \"ol\" : \"ul\";\n        const startAttr = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startAttr + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(item) {\n        let itemBody = \"\";\n        if (item.task) {\n            const checkbox = this.checkbox({\n                checked: !!item.checked\n            });\n            if (item.loose) {\n                if (item.tokens[0]?.type === \"paragraph\") {\n                    item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                        item.tokens[0].tokens[0].text = checkbox + \" \" + escape(item.tokens[0].tokens[0].text);\n                        item.tokens[0].tokens[0].escaped = true;\n                    }\n                } else {\n                    item.tokens.unshift({\n                        type: \"text\",\n                        raw: checkbox + \" \",\n                        text: checkbox + \" \",\n                        escaped: true\n                    });\n                }\n            } else {\n                itemBody += checkbox + \" \";\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = \"\";\n        // header\n        let cell = \"\";\n        for(let j = 0; j < token.header.length; j++){\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({\n            text: cell\n        });\n        let body = \"\";\n        for(let j = 0; j < token.rows.length; j++){\n            const row = token.rows[j];\n            cell = \"\";\n            for(let k = 0; k < row.length; k++){\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({\n                text: cell\n            });\n        }\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? \"th\" : \"td\";\n        const tag = token.align ? `<${type} align=\"${token.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */ strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${escape(text, true)}</code>`;\n    }\n    br(token) {\n        return \"<br>\";\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + escape(title) + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return escape(text);\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${escape(title)}\"`;\n        }\n        out += \">\";\n        return out;\n    }\n    text(token) {\n        return \"tokens\" in token && token.tokens ? this.parser.parseInline(token.tokens) : \"escaped\" in token && token.escaped ? token.text : escape(token.text);\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return \"\" + text;\n    }\n    image({ text }) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Parsing & Compiling\n */ class _Parser {\n    constructor(options){\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */ static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */ static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */ parse(tokens, top = true) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch(token.type){\n                case \"space\":\n                    {\n                        out += this.renderer.space(token);\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr(token);\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        out += this.renderer.heading(token);\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        out += this.renderer.code(token);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        out += this.renderer.table(token);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        out += this.renderer.blockquote(token);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        out += this.renderer.list(token);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        out += this.renderer.html(token);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        out += this.renderer.paragraph(token);\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = this.renderer.text(textToken);\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + this.renderer.text(textToken);\n                        }\n                        if (top) {\n                            out += this.renderer.paragraph({\n                                type: \"paragraph\",\n                                raw: body,\n                                text: body,\n                                tokens: [\n                                    {\n                                        type: \"text\",\n                                        raw: body,\n                                        text: body,\n                                        escaped: true\n                                    }\n                                ]\n                            });\n                        } else {\n                            out += body;\n                        }\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */ parseInline(tokens, renderer = this.renderer) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({\n                    parser: this\n                }, anyToken);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(anyToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch(token.type){\n                case \"escape\":\n                    {\n                        out += renderer.text(token);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        out += renderer.html(token);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        out += renderer.link(token);\n                        break;\n                    }\n                case \"image\":\n                    {\n                        out += renderer.image(token);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        out += renderer.strong(token);\n                        break;\n                    }\n                case \"em\":\n                    {\n                        out += renderer.em(token);\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        out += renderer.codespan(token);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br(token);\n                        break;\n                    }\n                case \"del\":\n                    {\n                        out += renderer.del(token);\n                        break;\n                    }\n                case \"text\":\n                    {\n                        out += renderer.text(token);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass _Hooks {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\",\n            \"processAllTokens\"\n        ]);\n    }\n    /**\n     * Process markdown before marked\n     */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */ postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */ processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */ provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */ provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.parseMarkdown(true);\n        this.parseInline = this.parseMarkdown(false);\n        this.Parser = _Parser;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.Tokenizer = _Tokenizer;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"parser\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args)=>{\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"rules\",\n                        \"lexer\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args)=>{\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"block\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options)=>{\n            const origOpt = {\n                ...options\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error(\"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.\"));\n            }\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : blockType ? _Lexer.lex : _Lexer.lexInline;\n            const parser = opt.hooks ? opt.hooks.provideParser() : blockType ? _Parser.parse : _Parser.parseInline;\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */ marked.options = marked.setOptions = function(options) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Gets the original marked default options.\n */ marked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n //# sourceMappingURL=marked.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUNELFNBQVNBO0lBQ0wsT0FBTztRQUNIQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxLQUFLO1FBQ0xDLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxZQUFZO0lBQ2hCO0FBQ0o7QUFDQSxJQUFJQyxZQUFZWDtBQUNoQixTQUFTWSxlQUFlQyxXQUFXO0lBQy9CRixZQUFZRTtBQUNoQjtBQUVBLE1BQU1DLFdBQVc7SUFBRUMsTUFBTSxJQUFNO0FBQUs7QUFDcEMsU0FBU0MsS0FBS0MsS0FBSyxFQUFFQyxNQUFNLEVBQUU7SUFDekIsSUFBSUMsU0FBUyxPQUFPRixVQUFVLFdBQVdBLFFBQVFBLE1BQU1FLE1BQU07SUFDN0QsTUFBTUMsTUFBTTtRQUNSQyxTQUFTLENBQUNDLE1BQU1DO1lBQ1osSUFBSUMsWUFBWSxPQUFPRCxRQUFRLFdBQVdBLE1BQU1BLElBQUlKLE1BQU07WUFDMURLLFlBQVlBLFVBQVVILE9BQU8sQ0FBQ0ksTUFBTUMsS0FBSyxFQUFFO1lBQzNDUCxTQUFTQSxPQUFPRSxPQUFPLENBQUNDLE1BQU1FO1lBQzlCLE9BQU9KO1FBQ1g7UUFDQU8sVUFBVTtZQUNOLE9BQU8sSUFBSUMsT0FBT1QsUUFBUUQ7UUFDOUI7SUFDSjtJQUNBLE9BQU9FO0FBQ1g7QUFDQSxNQUFNSyxRQUFRO0lBQ1ZJLGtCQUFrQjtJQUNsQkMsbUJBQW1CO0lBQ25CQyx3QkFBd0I7SUFDeEJDLGdCQUFnQjtJQUNoQkMsWUFBWTtJQUNaQyxtQkFBbUI7SUFDbkJDLGlCQUFpQjtJQUNqQkMsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkJDLGVBQWU7SUFDZkMscUJBQXFCO0lBQ3JCQyxXQUFXO0lBQ1hDLGlC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M1Isc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktbmV4dGpzLWJsb2cvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzP2M3MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgdjE1LjAuNyAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyNSwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgZXh0ZW5zaW9uczogbnVsbCxcbiAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICBob29rczogbnVsbCxcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLFxuICAgICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgdG9rZW5pemVyOiBudWxsLFxuICAgICAgICB3YWxrVG9rZW5zOiBudWxsLFxuICAgIH07XG59XG5sZXQgX2RlZmF1bHRzID0gX2dldERlZmF1bHRzKCk7XG5mdW5jdGlvbiBjaGFuZ2VEZWZhdWx0cyhuZXdEZWZhdWx0cykge1xuICAgIF9kZWZhdWx0cyA9IG5ld0RlZmF1bHRzO1xufVxuXG5jb25zdCBub29wVGVzdCA9IHsgZXhlYzogKCkgPT4gbnVsbCB9O1xuZnVuY3Rpb24gZWRpdChyZWdleCwgb3B0ID0gJycpIHtcbiAgICBsZXQgc291cmNlID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgcmVwbGFjZTogKG5hbWUsIHZhbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbFNvdXJjZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsIDogdmFsLnNvdXJjZTtcbiAgICAgICAgICAgIHZhbFNvdXJjZSA9IHZhbFNvdXJjZS5yZXBsYWNlKG90aGVyLmNhcmV0LCAnJDEnKTtcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKG5hbWUsIHZhbFNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuICAgICAgICBnZXRSZWdleDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLCBvcHQpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn1cbmNvbnN0IG90aGVyID0ge1xuICAgIGNvZGVSZW1vdmVJbmRlbnQ6IC9eKD86IHsxLDR9fCB7MCwzfVxcdCkvZ20sXG4gICAgb3V0cHV0TGlua1JlcGxhY2U6IC9cXFxcKFtcXFtcXF1dKS9nLFxuICAgIGluZGVudENvZGVDb21wZW5zYXRpb246IC9eKFxccyspKD86YGBgKS8sXG4gICAgYmVnaW5uaW5nU3BhY2U6IC9eXFxzKy8sXG4gICAgZW5kaW5nSGFzaDogLyMkLyxcbiAgICBzdGFydGluZ1NwYWNlQ2hhcjogL14gLyxcbiAgICBlbmRpbmdTcGFjZUNoYXI6IC8gJC8sXG4gICAgbm9uU3BhY2VDaGFyOiAvW14gXS8sXG4gICAgbmV3TGluZUNoYXJHbG9iYWw6IC9cXG4vZyxcbiAgICB0YWJDaGFyR2xvYmFsOiAvXFx0L2csXG4gICAgbXVsdGlwbGVTcGFjZUdsb2JhbDogL1xccysvZyxcbiAgICBibGFua0xpbmU6IC9eWyBcXHRdKiQvLFxuICAgIGRvdWJsZUJsYW5rTGluZTogL1xcblsgXFx0XSpcXG5bIFxcdF0qJC8sXG4gICAgYmxvY2txdW90ZVN0YXJ0OiAvXiB7MCwzfT4vLFxuICAgIGJsb2NrcXVvdGVTZXRleHRSZXBsYWNlOiAvXFxuIHswLDN9KCg/Oj0rfC0rKSAqKSg/PVxcbnwkKS9nLFxuICAgIGJsb2NrcXVvdGVTZXRleHRSZXBsYWNlMjogL14gezAsM30+WyBcXHRdPy9nbSxcbiAgICBsaXN0UmVwbGFjZVRhYnM6IC9eXFx0Ky8sXG4gICAgbGlzdFJlcGxhY2VOZXN0aW5nOiAvXiB7MSw0fSg/PSggezR9KSpbXiBdKS9nLFxuICAgIGxpc3RJc1Rhc2s6IC9eXFxbWyB4WF1cXF0gLyxcbiAgICBsaXN0UmVwbGFjZVRhc2s6IC9eXFxbWyB4WF1cXF0gKy8sXG4gICAgYW55TGluZTogL1xcbi4qXFxuLyxcbiAgICBocmVmQnJhY2tldHM6IC9ePCguKik+JC8sXG4gICAgdGFibGVEZWxpbWl0ZXI6IC9bOnxdLyxcbiAgICB0YWJsZUFsaWduQ2hhcnM6IC9eXFx8fFxcfCAqJC9nLFxuICAgIHRhYmxlUm93QmxhbmtMaW5lOiAvXFxuWyBcXHRdKiQvLFxuICAgIHRhYmxlQWxpZ25SaWdodDogL14gKi0rOiAqJC8sXG4gICAgdGFibGVBbGlnbkNlbnRlcjogL14gKjotKzogKiQvLFxuICAgIHRhYmxlQWxpZ25MZWZ0OiAvXiAqOi0rICokLyxcbiAgICBzdGFydEFUYWc6IC9ePGEgL2ksXG4gICAgZW5kQVRhZzogL148XFwvYT4vaSxcbiAgICBzdGFydFByZVNjcmlwdFRhZzogL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLFxuICAgIGVuZFByZVNjcmlwdFRhZzogL148XFwvKHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLFxuICAgIHN0YXJ0QW5nbGVCcmFja2V0OiAvXjwvLFxuICAgIGVuZEFuZ2xlQnJhY2tldDogLz4kLyxcbiAgICBwZWRhbnRpY0hyZWZUaXRsZTogL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLFxuICAgIHVuaWNvZGVBbHBoYU51bWVyaWM6IC9bXFxwe0x9XFxwe059XS91LFxuICAgIGVzY2FwZVRlc3Q6IC9bJjw+XCInXS8sXG4gICAgZXNjYXBlUmVwbGFjZTogL1smPD5cIiddL2csXG4gICAgZXNjYXBlVGVzdE5vRW5jb2RlOiAvWzw+XCInXXwmKD8hKCNcXGR7MSw3fXwjW1h4XVthLWZBLUYwLTldezEsNn18XFx3Kyk7KS8sXG4gICAgZXNjYXBlUmVwbGFjZU5vRW5jb2RlOiAvWzw+XCInXXwmKD8hKCNcXGR7MSw3fXwjW1h4XVthLWZBLUYwLTldezEsNn18XFx3Kyk7KS9nLFxuICAgIHVuZXNjYXBlVGVzdDogLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZyxcbiAgICBjYXJldDogLyhefFteXFxbXSlcXF4vZyxcbiAgICBwZXJjZW50RGVjb2RlOiAvJTI1L2csXG4gICAgZmluZFBpcGU6IC9cXHwvZyxcbiAgICBzcGxpdFBpcGU6IC8gXFx8LyxcbiAgICBzbGFzaFBpcGU6IC9cXFxcXFx8L2csXG4gICAgY2FycmlhZ2VSZXR1cm46IC9cXHJcXG58XFxyL2csXG4gICAgc3BhY2VMaW5lOiAvXiArJC9nbSxcbiAgICBub3RTcGFjZVN0YXJ0OiAvXlxcUyovLFxuICAgIGVuZGluZ05ld2xpbmU6IC9cXG4kLyxcbiAgICBsaXN0SXRlbVJlZ2V4OiAoYnVsbCkgPT4gbmV3IFJlZ0V4cChgXiggezAsM30ke2J1bGx9KSgoPzpbXFx0IF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApLFxuICAgIG5leHRCdWxsZXRSZWdleDogKGluZGVudCkgPT4gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpbKistXXxcXFxcZHsxLDl9Wy4pXSkoKD86WyBcXHRdW15cXFxcbl0qKT8oPzpcXFxcbnwkKSlgKSxcbiAgICBoclJlZ2V4OiAoaW5kZW50KSA9PiBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCksXG4gICAgZmVuY2VzQmVnaW5SZWdleDogKGluZGVudCkgPT4gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpcXGBcXGBcXGB8fn5+KWApLFxuICAgIGhlYWRpbmdCZWdpblJlZ2V4OiAoaW5kZW50KSA9PiBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSNgKSxcbiAgICBodG1sQmVnaW5SZWdleDogKGluZGVudCkgPT4gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX08KD86W2Etel0uKj58IS0tKWAsICdpJyksXG59O1xuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cbmNvbnN0IG5ld2xpbmUgPSAvXig/OlsgXFx0XSooPzpcXG58JCkpKy87XG5jb25zdCBibG9ja0NvZGUgPSAvXigoPzogezR9fCB7MCwzfVxcdClbXlxcbl0rKD86XFxuKD86WyBcXHRdKig/OlxcbnwkKSkqKT8pKy87XG5jb25zdCBmZW5jZXMgPSAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qKD86XFxufCQpKXx+ezMsfSkoW15cXG5dKikoPzpcXG58JCkoPzp8KFtcXHNcXFNdKj8pKD86XFxufCQpKSg/OiB7MCwzfVxcMVt+YF0qICooPz1cXG58JCl8JCkvO1xuY29uc3QgaHIgPSAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvO1xuY29uc3QgaGVhZGluZyA9IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS87XG5jb25zdCBidWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5jb25zdCBsaGVhZGluZ0NvcmUgPSAvXig/IWJ1bGwgfGJsb2NrQ29kZXxmZW5jZXN8YmxvY2txdW90ZXxoZWFkaW5nfGh0bWx8dGFibGUpKCg/Oi58XFxuKD8hXFxzKj9cXG58YnVsbCB8YmxvY2tDb2RlfGZlbmNlc3xibG9ja3F1b3RlfGhlYWRpbmd8aHRtbHx0YWJsZSkpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS87XG5jb25zdCBsaGVhZGluZyA9IGVkaXQobGhlYWRpbmdDb3JlKVxuICAgIC5yZXBsYWNlKC9idWxsL2csIGJ1bGxldCkgLy8gbGlzdHMgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9ibG9ja0NvZGUvZywgLyg/OiB7NH18IHswLDN9XFx0KS8pIC8vIGluZGVudGVkIGNvZGUgYmxvY2tzIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvZmVuY2VzL2csIC8gezAsM30oPzpgezMsfXx+ezMsfSkvKSAvLyBmZW5jZWQgY29kZSBibG9ja3MgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9ibG9ja3F1b3RlL2csIC8gezAsM30+LykgLy8gYmxvY2txdW90ZSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2hlYWRpbmcvZywgLyB7MCwzfSN7MSw2fS8pIC8vIEFUWCBoZWFkaW5nIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvaHRtbC9nLCAvIHswLDN9PFteXFxuPl0rPlxcbi8pIC8vIGJsb2NrIGh0bWwgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9cXHx0YWJsZS9nLCAnJykgLy8gdGFibGUgbm90IGluIGNvbW1vbm1hcmtcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGxoZWFkaW5nR2ZtID0gZWRpdChsaGVhZGluZ0NvcmUpXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYnVsbGV0KSAvLyBsaXN0cyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2Jsb2NrQ29kZS9nLCAvKD86IHs0fXwgezAsM31cXHQpLykgLy8gaW5kZW50ZWQgY29kZSBibG9ja3MgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9mZW5jZXMvZywgLyB7MCwzfSg/OmB7Myx9fH57Myx9KS8pIC8vIGZlbmNlZCBjb2RlIGJsb2NrcyBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL2Jsb2NrcXVvdGUvZywgLyB7MCwzfT4vKSAvLyBibG9ja3F1b3RlIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgvaGVhZGluZy9nLCAvIHswLDN9I3sxLDZ9LykgLy8gQVRYIGhlYWRpbmcgY2FuIGludGVycnVwdFxuICAgIC5yZXBsYWNlKC9odG1sL2csIC8gezAsM308W15cXG4+XSs+XFxuLykgLy8gYmxvY2sgaHRtbCBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoL3RhYmxlL2csIC8gezAsM31cXHw/KD86WzpcXC0gXSpcXHwpK1tcXDpcXC0gXSpcXG4vKSAvLyB0YWJsZSBjYW4gaW50ZXJydXB0XG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfcGFyYWdyYXBoID0gL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvO1xuY29uc3QgYmxvY2tUZXh0ID0gL15bXlxcbl0rLztcbmNvbnN0IF9ibG9ja0xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmNvbnN0IGRlZiA9IGVkaXQoL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuWyBcXHRdKik/KFtePFxcc11bXlxcc10qfDwuKj8+KSg/Oig/OiArKD86XFxuWyBcXHRdKik/fCAqXFxuWyBcXHRdKikodGl0bGUpKT8gKig/Olxcbit8JCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9ibG9ja0xhYmVsKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBsaXN0ID0gZWRpdCgvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJ1xuICAgICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgICArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbidcbiAgICArICd8cHxwYXJhbXxzZWFyY2h8c2VjdGlvbnxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlJ1xuICAgICsgJ3x0cnx0cmFja3x1bCc7XG5jb25zdCBfY29tbWVudCA9IC88IS0tKD86LT8+fFtcXHNcXFNdKj8oPzotLT58JCkpLztcbmNvbnN0IGh0bWwgPSBlZGl0KCdeIHswLDN9KD86JyAvLyBvcHRpb25hbCBpbmRlbnRhdGlvblxuICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICsgJ3xjb21tZW50W15cXFxcbl0qKFxcXFxuK3wkKScgLy8gKDIpXG4gICAgKyAnfDxcXFxcP1tcXFxcc1xcXFxTXSo/KD86XFxcXD8+XFxcXG4qfCQpJyAvLyAoMylcbiAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgKyAnfDwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj8oPzpcXFxcXVxcXFxdPlxcXFxuKnwkKScgLy8gKDUpXG4gICAgKyAnfDwvPyh0YWcpKD86ICt8XFxcXG58Lz8+KVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG5bIFxcdF0qKStcXFxcbnwkKScgLy8gKDcpIG9wZW4gdGFnXG4gICAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuWyBcXHRdKikrXFxcXG58JCknIC8vICg3KSBjbG9zaW5nIHRhZ1xuICAgICsgJyknLCAnaScpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBfY29tbWVudClcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZylcbiAgICAucmVwbGFjZSgnYXR0cmlidXRlJywgLyArW2EtekEtWjpfXVtcXHcuOi1dKig/OiAqPSAqXCJbXlwiXFxuXSpcInwgKj0gKidbXidcXG5dKid8ICo9ICpbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IHBhcmFncmFwaCA9IGVkaXQoX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleHQgaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAgIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGJsb2NrcXVvdGUgPSBlZGl0KC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8pXG4gICAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIHBhcmFncmFwaClcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgYmxvY2tOb3JtYWwgPSB7XG4gICAgYmxvY2txdW90ZSxcbiAgICBjb2RlOiBibG9ja0NvZGUsXG4gICAgZGVmLFxuICAgIGZlbmNlcyxcbiAgICBoZWFkaW5nLFxuICAgIGhyLFxuICAgIGh0bWwsXG4gICAgbGhlYWRpbmcsXG4gICAgbGlzdCxcbiAgICBuZXdsaW5lLFxuICAgIHBhcmFncmFwaCxcbiAgICB0YWJsZTogbm9vcFRlc3QsXG4gICAgdGV4dDogYmxvY2tUZXh0LFxufTtcbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgZ2ZtVGFibGUgPSBlZGl0KCdeICooW15cXFxcbiBdLiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSgoPzpcXFxcfCAqKT86Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKD86XFxcXHwgKik/KScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScpIC8vIENlbGxzXG4gICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdjb2RlJywgJyg/OiB7NH18IHswLDN9XFx0KVteXFxcXG5dJylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYmxvY2tHZm0gPSB7XG4gICAgLi4uYmxvY2tOb3JtYWwsXG4gICAgbGhlYWRpbmc6IGxoZWFkaW5nR2ZtLFxuICAgIHRhYmxlOiBnZm1UYWJsZSxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleHQgaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAgICAgICAucmVwbGFjZSgndGFibGUnLCBnZm1UYWJsZSkgLy8gaW50ZXJydXB0IHBhcmFncmFwaHMgd2l0aCB0YWJsZVxuICAgICAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAgICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgICAgICAucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAgICAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAgICAgLnJlcGxhY2UoJ3RhZycsIF90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgICAgIC5nZXRSZWdleCgpLFxufTtcbi8qKlxuICogUGVkYW50aWMgZ3JhbW1hciAob3JpZ2luYWwgSm9obiBHcnViZXIncyBsb29zZSBtYXJrZG93biBzcGVjaWZpY2F0aW9uKVxuICovXG5jb25zdCBibG9ja1BlZGFudGljID0ge1xuICAgIC4uLmJsb2NrTm9ybWFsLFxuICAgIGh0bWw6IGVkaXQoJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJ1xuICAgICAgICArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICAgICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpXG4gICAgICAgIC5yZXBsYWNlKCdjb21tZW50JywgX2NvbW1lbnQpXG4gICAgICAgIC5yZXBsYWNlKC90YWcvZywgJyg/ISg/OidcbiAgICAgICAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YidcbiAgICAgICAgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknXG4gICAgICAgICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpXG4gICAgICAgIC5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCwgLy8gZmVuY2VzIG5vdCBzdXBwb3J0ZWRcbiAgICBsaGVhZGluZzogL14oLis/KVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICAgIHBhcmFncmFwaDogZWRpdChfcGFyYWdyYXBoKVxuICAgICAgICAucmVwbGFjZSgnaHInLCBocilcbiAgICAgICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnICojezEsNn0gKlteXFxuXScpXG4gICAgICAgIC5yZXBsYWNlKCdsaGVhZGluZycsIGxoZWFkaW5nKVxuICAgICAgICAucmVwbGFjZSgnfHRhYmxlJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgICAgICAucmVwbGFjZSgnfGZlbmNlcycsICcnKVxuICAgICAgICAucmVwbGFjZSgnfGxpc3QnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3xodG1sJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8dGFnJywgJycpXG4gICAgICAgIC5nZXRSZWdleCgpLFxufTtcbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgZXNjYXBlJDEgPSAvXlxcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pLztcbmNvbnN0IGlubGluZUNvZGUgPSAvXihgKykoW15gXXxbXmBdW1xcc1xcU10qP1teYF0pXFwxKD8hYCkvO1xuY29uc3QgYnIgPSAvXiggezIsfXxcXFxcKVxcbig/IVxccyokKS87XG5jb25zdCBpbmxpbmVUZXh0ID0gL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLztcbi8vIGxpc3Qgb2YgdW5pY29kZSBwdW5jdHVhdGlvbiBtYXJrcywgcGx1cyBhbnkgbWlzc2luZyBjaGFyYWN0ZXJzIGZyb20gQ29tbW9uTWFyayBzcGVjXG5jb25zdCBfcHVuY3R1YXRpb24gPSAvW1xccHtQfVxccHtTfV0vdTtcbmNvbnN0IF9wdW5jdHVhdGlvbk9yU3BhY2UgPSAvW1xcc1xccHtQfVxccHtTfV0vdTtcbmNvbnN0IF9ub3RQdW5jdHVhdGlvbk9yU3BhY2UgPSAvW15cXHNcXHB7UH1cXHB7U31dL3U7XG5jb25zdCBwdW5jdHVhdGlvbiA9IGVkaXQoL14oKD8hWypfXSlwdW5jdFNwYWNlKS8sICd1JylcbiAgICAucmVwbGFjZSgvcHVuY3RTcGFjZS9nLCBfcHVuY3R1YXRpb25PclNwYWNlKS5nZXRSZWdleCgpO1xuLy8gR0ZNIGFsbG93cyB+IGluc2lkZSBzdHJvbmcgYW5kIGVtIGZvciBzdHJpa2V0aHJvdWdoXG5jb25zdCBfcHVuY3R1YXRpb25HZm1TdHJvbmdFbSA9IC8oPyF+KVtcXHB7UH1cXHB7U31dL3U7XG5jb25zdCBfcHVuY3R1YXRpb25PclNwYWNlR2ZtU3Ryb25nRW0gPSAvKD8hfilbXFxzXFxwe1B9XFxwe1N9XS91O1xuY29uc3QgX25vdFB1bmN0dWF0aW9uT3JTcGFjZUdmbVN0cm9uZ0VtID0gLyg/OlteXFxzXFxwe1B9XFxwe1N9XXx+KS91O1xuLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cbmNvbnN0IGJsb2NrU2tpcCA9IC9cXFtbXltcXF1dKj9cXF1cXCgoPzpcXFxcLnxbXlxcXFxcXChcXCldfFxcKCg/OlxcXFwufFteXFxcXFxcKFxcKV0pKlxcKSkqXFwpfGBbXmBdKj9gfDxbXjw+XSo/Pi9nO1xuY29uc3QgZW1TdHJvbmdMRGVsaW1Db3JlID0gL14oPzpcXCorKD86KCg/IVxcKilwdW5jdCl8W15cXHMqXSkpfF5fKyg/OigoPyFfKXB1bmN0KXwoW15cXHNfXSkpLztcbmNvbnN0IGVtU3Ryb25nTERlbGltID0gZWRpdChlbVN0cm9uZ0xEZWxpbUNvcmUsICd1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgZW1TdHJvbmdMRGVsaW1HZm0gPSBlZGl0KGVtU3Ryb25nTERlbGltQ29yZSwgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb25HZm1TdHJvbmdFbSlcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGVtU3Ryb25nUkRlbGltQXN0Q29yZSA9ICdeW15fKl0qP19fW15fKl0qP1xcXFwqW15fKl0qPyg/PV9fKScgLy8gU2tpcCBvcnBoYW4gaW5zaWRlIHN0cm9uZ1xuICAgICsgJ3xbXipdKyg/PVteKl0pJyAvLyBDb25zdW1lIHRvIGRlbGltXG4gICAgKyAnfCg/IVxcXFwqKXB1bmN0KFxcXFwqKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgIyoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xub3RQdW5jdFNwYWNlKFxcXFwqKykoPyFcXFxcKikoPz1wdW5jdFNwYWNlfCQpJyAvLyAoMikgYSoqKiMsIGEqKiogY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXFxcXCopcHVuY3RTcGFjZShcXFxcKispKD89bm90UHVuY3RTcGFjZSknIC8vICgzKSAjKioqYSwgKioqYSBjYW4gb25seSBiZSBMZWZ0IERlbGltaXRlclxuICAgICsgJ3xbXFxcXHNdKFxcXFwqKykoPyFcXFxcKikoPz1wdW5jdCknIC8vICg0KSAqKiojIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IVxcXFwqKXB1bmN0KFxcXFwqKykoPyFcXFxcKikoPz1wdW5jdCknIC8vICg1KSAjKioqIyBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfG5vdFB1bmN0U3BhY2UoXFxcXCorKSg/PW5vdFB1bmN0U3BhY2UpJzsgLy8gKDYpIGEqKiphIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbWl0ZXJcbmNvbnN0IGVtU3Ryb25nUkRlbGltQXN0ID0gZWRpdChlbVN0cm9uZ1JEZWxpbUFzdENvcmUsICdndScpXG4gICAgLnJlcGxhY2UoL25vdFB1bmN0U3BhY2UvZywgX25vdFB1bmN0dWF0aW9uT3JTcGFjZSlcbiAgICAucmVwbGFjZSgvcHVuY3RTcGFjZS9nLCBfcHVuY3R1YXRpb25PclNwYWNlKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBfcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBlbVN0cm9uZ1JEZWxpbUFzdEdmbSA9IGVkaXQoZW1TdHJvbmdSRGVsaW1Bc3RDb3JlLCAnZ3UnKVxuICAgIC5yZXBsYWNlKC9ub3RQdW5jdFNwYWNlL2csIF9ub3RQdW5jdHVhdGlvbk9yU3BhY2VHZm1TdHJvbmdFbSlcbiAgICAucmVwbGFjZSgvcHVuY3RTcGFjZS9nLCBfcHVuY3R1YXRpb25PclNwYWNlR2ZtU3Ryb25nRW0pXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbkdmbVN0cm9uZ0VtKVxuICAgIC5nZXRSZWdleCgpO1xuLy8gKDYpIE5vdCBhbGxvd2VkIGZvciBfXG5jb25zdCBlbVN0cm9uZ1JEZWxpbVVuZCA9IGVkaXQoJ15bXl8qXSo/XFxcXCpcXFxcKlteXypdKj9fW15fKl0qPyg/PVxcXFwqXFxcXCopJyAvLyBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nXG4gICAgKyAnfFteX10rKD89W15fXSknIC8vIENvbnN1bWUgdG8gZGVsaW1cbiAgICArICd8KD8hXylwdW5jdChfKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgI19fXyBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xub3RQdW5jdFNwYWNlKF8rKSg/IV8pKD89cHVuY3RTcGFjZXwkKScgLy8gKDIpIGFfX18jLCBhX19fIGNhbiBvbmx5IGJlIGEgUmlnaHQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pcHVuY3RTcGFjZShfKykoPz1ub3RQdW5jdFNwYWNlKScgLy8gKDMpICNfX19hLCBfX19hIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfFtcXFxcc10oXyspKD8hXykoPz1wdW5jdCknIC8vICg0KSBfX18jIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pcHVuY3QoXyspKD8hXykoPz1wdW5jdCknLCAnZ3UnKSAvLyAoNSkgI19fXyMgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgIC5yZXBsYWNlKC9ub3RQdW5jdFNwYWNlL2csIF9ub3RQdW5jdHVhdGlvbk9yU3BhY2UpXG4gICAgLnJlcGxhY2UoL3B1bmN0U3BhY2UvZywgX3B1bmN0dWF0aW9uT3JTcGFjZSlcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYW55UHVuY3R1YXRpb24gPSBlZGl0KC9cXFxcKHB1bmN0KS8sICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGF1dG9saW5rID0gZWRpdCgvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vKVxuICAgIC5yZXBsYWNlKCdzY2hlbWUnLCAvW2EtekEtWl1bYS16QS1aMC05Ky4tXXsxLDMxfS8pXG4gICAgLnJlcGxhY2UoJ2VtYWlsJywgL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfaW5saW5lQ29tbWVudCA9IGVkaXQoX2NvbW1lbnQpLnJlcGxhY2UoJyg/Oi0tPnwkKScsICctLT4nKS5nZXRSZWdleCgpO1xuY29uc3QgdGFnID0gZWRpdCgnXmNvbW1lbnQnXG4gICAgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicpIC8vIENEQVRBIHNlY3Rpb25cbiAgICAucmVwbGFjZSgnY29tbWVudCcsIF9pbmxpbmVDb21tZW50KVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvXFxzK1thLXpBLVo6X11bXFx3LjotXSooPzpcXHMqPVxccypcIlteXCJdKlwifFxccyo9XFxzKidbXiddKid8XFxzKj1cXHMqW15cXHNcIic9PD5gXSspPy8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfaW5saW5lTGFiZWwgPSAvKD86XFxbKD86XFxcXC58W15cXFtcXF1cXFxcXSkqXFxdfFxcXFwufGBbXmBdKmB8W15cXFtcXF1cXFxcYF0pKj8vO1xuY29uc3QgbGluayA9IGVkaXQoL14hP1xcWyhsYWJlbClcXF1cXChcXHMqKGhyZWYpKD86XFxzKyh0aXRsZSkpP1xccypcXCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAucmVwbGFjZSgnaHJlZicsIC88KD86XFxcXC58W15cXG48PlxcXFxdKSs+fFteXFxzXFx4MDAtXFx4MWZdKi8pXG4gICAgLnJlcGxhY2UoJ3RpdGxlJywgL1wiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCcoPzpcXFxcJz98W14nXFxcXF0pKid8XFwoKD86XFxcXFxcKT98W14pXFxcXF0pKlxcKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCByZWZsaW5rID0gZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcWyhyZWYpXFxdLylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBfaW5saW5lTGFiZWwpXG4gICAgLnJlcGxhY2UoJ3JlZicsIF9ibG9ja0xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3Qgbm9saW5rID0gZWRpdCgvXiE/XFxbKHJlZilcXF0oPzpcXFtcXF0pPy8pXG4gICAgLnJlcGxhY2UoJ3JlZicsIF9ibG9ja0xhYmVsKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcmVmbGlua1NlYXJjaCA9IGVkaXQoJ3JlZmxpbmt8bm9saW5rKD8hXFxcXCgpJywgJ2cnKVxuICAgIC5yZXBsYWNlKCdyZWZsaW5rJywgcmVmbGluaylcbiAgICAucmVwbGFjZSgnbm9saW5rJywgbm9saW5rKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lTm9ybWFsID0ge1xuICAgIF9iYWNrcGVkYWw6IG5vb3BUZXN0LCAvLyBvbmx5IHVzZWQgZm9yIEdGTSB1cmxcbiAgICBhbnlQdW5jdHVhdGlvbixcbiAgICBhdXRvbGluayxcbiAgICBibG9ja1NraXAsXG4gICAgYnIsXG4gICAgY29kZTogaW5saW5lQ29kZSxcbiAgICBkZWw6IG5vb3BUZXN0LFxuICAgIGVtU3Ryb25nTERlbGltLFxuICAgIGVtU3Ryb25nUkRlbGltQXN0LFxuICAgIGVtU3Ryb25nUkRlbGltVW5kLFxuICAgIGVzY2FwZTogZXNjYXBlJDEsXG4gICAgbGluayxcbiAgICBub2xpbmssXG4gICAgcHVuY3R1YXRpb24sXG4gICAgcmVmbGluayxcbiAgICByZWZsaW5rU2VhcmNoLFxuICAgIHRhZyxcbiAgICB0ZXh0OiBpbmxpbmVUZXh0LFxuICAgIHVybDogbm9vcFRlc3QsXG59O1xuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVQZWRhbnRpYyA9IHtcbiAgICAuLi5pbmxpbmVOb3JtYWwsXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KCksXG59O1xuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuY29uc3QgaW5saW5lR2ZtID0ge1xuICAgIC4uLmlubGluZU5vcm1hbCxcbiAgICBlbVN0cm9uZ1JEZWxpbUFzdDogZW1TdHJvbmdSRGVsaW1Bc3RHZm0sXG4gICAgZW1TdHJvbmdMRGVsaW06IGVtU3Ryb25nTERlbGltR2ZtLFxuICAgIHVybDogZWRpdCgvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sICdpJylcbiAgICAgICAgLnJlcGxhY2UoJ2VtYWlsJywgL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoKD86XFxcXC58W15cXFxcXSkqPyg/OlxcXFwufFteXFxzflxcXFxdKSlcXDEoPz1bXn5dfCQpLyxcbiAgICB0ZXh0OiAvXihbYH5dK3xbXmB+XSkoPzooPz0gezIsfVxcbil8KD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl9dfFxcYl98aHR0cHM/OlxcL1xcL3xmdHA6XFwvXFwvfHd3d1xcLnwkKXxbXiBdKD89IHsyLH1cXG4pfFteYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dKD89W2EtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXStAKSkpLyxcbn07XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZUJyZWFrcyA9IHtcbiAgICAuLi5pbmxpbmVHZm0sXG4gICAgYnI6IGVkaXQoYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmVHZm0udGV4dClcbiAgICAgICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgICAgIC5nZXRSZWdleCgpLFxufTtcbi8qKlxuICogZXhwb3J0c1xuICovXG5jb25zdCBibG9jayA9IHtcbiAgICBub3JtYWw6IGJsb2NrTm9ybWFsLFxuICAgIGdmbTogYmxvY2tHZm0sXG4gICAgcGVkYW50aWM6IGJsb2NrUGVkYW50aWMsXG59O1xuY29uc3QgaW5saW5lID0ge1xuICAgIG5vcm1hbDogaW5saW5lTm9ybWFsLFxuICAgIGdmbTogaW5saW5lR2ZtLFxuICAgIGJyZWFrczogaW5saW5lQnJlYWtzLFxuICAgIHBlZGFudGljOiBpbmxpbmVQZWRhbnRpYyxcbn07XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnLFxufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlKGh0bWwsIGVuY29kZSkge1xuICAgIGlmIChlbmNvZGUpIHtcbiAgICAgICAgaWYgKG90aGVyLmVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShvdGhlci5lc2NhcGVSZXBsYWNlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvdGhlci5lc2NhcGVUZXN0Tm9FbmNvZGUudGVzdChodG1sKSkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZShvdGhlci5lc2NhcGVSZXBsYWNlTm9FbmNvZGUsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHRtbDtcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKGhyZWYpIHtcbiAgICB0cnkge1xuICAgICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2Uob3RoZXIucGVyY2VudERlY29kZSwgJyUnKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWY7XG59XG5mdW5jdGlvbiBzcGxpdENlbGxzKHRhYmxlUm93LCBjb3VudCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IGV2ZXJ5IGNlbGwtZGVsaW1pdGluZyBwaXBlIGhhcyBhIHNwYWNlXG4gICAgLy8gYmVmb3JlIGl0IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb20gYW4gZXNjYXBlZCBwaXBlXG4gICAgY29uc3Qgcm93ID0gdGFibGVSb3cucmVwbGFjZShvdGhlci5maW5kUGlwZSwgKG1hdGNoLCBvZmZzZXQsIHN0cikgPT4ge1xuICAgICAgICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VyciA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKVxuICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAgICAgLy8gc28gd2UgbGVhdmUgaXQgYWxvbmVcbiAgICAgICAgICAgIHJldHVybiAnfCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGQgc3BhY2UgYmVmb3JlIHVuZXNjYXBlZCB8XG4gICAgICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgICAgfVxuICAgIH0pLCBjZWxscyA9IHJvdy5zcGxpdChvdGhlci5zcGxpdFBpcGUpO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBGaXJzdC9sYXN0IGNlbGwgaW4gYSByb3cgY2Fubm90IGJlIGVtcHR5IGlmIGl0IGhhcyBubyBsZWFkaW5nL3RyYWlsaW5nIHBpcGVcbiAgICBpZiAoIWNlbGxzWzBdLnRyaW0oKSkge1xuICAgICAgICBjZWxscy5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gMCAmJiAhY2VsbHMuYXQoLTEpPy50cmltKCkpIHtcbiAgICAgICAgY2VsbHMucG9wKCk7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpXG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2Uob3RoZXIuc2xhc2hQaXBlLCAnfCcpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbHM7XG59XG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gKiAvYyokLyBpcyB2dWxuZXJhYmxlIHRvIFJFRE9TLlxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEBwYXJhbSBjXG4gKiBAcGFyYW0gaW52ZXJ0IFJlbW92ZSBzdWZmaXggb2Ygbm9uLWMgY2hhcnMgaW5zdGVhZC4gRGVmYXVsdCBmYWxzZXkuXG4gKi9cbmZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgY29uc3QgbCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMZW5ndGggb2Ygc3VmZml4IG1hdGNoaW5nIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIGxldCBzdWZmTGVuID0gMDtcbiAgICAvLyBTdGVwIGxlZnQgdW50aWwgd2UgZmFpbCB0byBtYXRjaCB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgICAgY29uc3QgY3VyckNoYXIgPSBzdHIuY2hhckF0KGwgLSBzdWZmTGVuIC0gMSk7XG4gICAgICAgIGlmIChjdXJyQ2hhciA9PT0gYyAmJiB0cnVlKSB7XG4gICAgICAgICAgICBzdWZmTGVuKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIGwgLSBzdWZmTGVuKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGxldmVsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdywgbGV4ZXIsIHJ1bGVzKSB7XG4gICAgY29uc3QgaHJlZiA9IGxpbmsuaHJlZjtcbiAgICBjb25zdCB0aXRsZSA9IGxpbmsudGl0bGUgfHwgbnVsbDtcbiAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UocnVsZXMub3RoZXIub3V0cHV0TGlua1JlcGxhY2UsICckMScpO1xuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgIH07XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHJhdyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHRleHQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0LCBydWxlcykge1xuICAgIGNvbnN0IG1hdGNoSW5kZW50VG9Db2RlID0gcmF3Lm1hdGNoKHJ1bGVzLm90aGVyLmluZGVudENvZGVDb21wZW5zYXRpb24pO1xuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50VG9Db2RlID0gbWF0Y2hJbmRlbnRUb0NvZGVbMV07XG4gICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2gocnVsZXMub3RoZXIuYmVnaW5uaW5nU3BhY2UpO1xuICAgICAgICBpZiAobWF0Y2hJbmRlbnRJbk5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpbmRlbnRJbk5vZGVdID0gbWF0Y2hJbmRlbnRJbk5vZGU7XG4gICAgICAgIGlmIChpbmRlbnRJbk5vZGUubGVuZ3RoID49IGluZGVudFRvQ29kZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbi8qKlxuICogVG9rZW5pemVyXG4gKi9cbmNsYXNzIF9Ub2tlbml6ZXIge1xuICAgIG9wdGlvbnM7XG4gICAgcnVsZXM7IC8vIHNldCBieSB0aGUgbGV4ZXJcbiAgICBsZXhlcjsgLy8gc2V0IGJ5IHRoZSBsZXhlclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIHNwYWNlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5ld2xpbmUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwICYmIGNhcFswXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzcGFjZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmNvZGVSZW1vdmVJbmRlbnQsICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgOiB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmZW5jZXMoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZmVuY2VzLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCBjYXBbM10gfHwgJycsIHRoaXMucnVsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5vdGhlci5lbmRpbmdIYXNoLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkID0gcnRyaW0odGV4dCwgJyMnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRyaW1tZWQgfHwgdGhpcy5ydWxlcy5vdGhlci5lbmRpbmdTcGFjZUNoYXIudGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBocihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hyJyxcbiAgICAgICAgICAgICAgICByYXc6IHJ0cmltKGNhcFswXSwgJ1xcbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja3F1b3RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSBydHJpbShjYXBbMF0sICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICAgICAgICB3aGlsZSAobGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpbkJsb2NrcXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IGxpbmVzIHVwIHRvIGEgY29udGludWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzLm90aGVyLmJsb2NrcXVvdGVTdGFydC50ZXN0KGxpbmVzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmVzLnB1c2gobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5CbG9ja3F1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaW5CbG9ja3F1b3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGluZXMucHVzaChsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lcyA9IGxpbmVzLnNsaWNlKGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSYXcgPSBjdXJyZW50TGluZXMuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFRleHQgPSBjdXJyZW50UmF3XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZWNlZGUgc2V0ZXh0IGNvbnRpbnVhdGlvbiB3aXRoIDQgc3BhY2VzIHNvIGl0IGlzbid0IGEgc2V0ZXh0XG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHRoaXMucnVsZXMub3RoZXIuYmxvY2txdW90ZVNldGV4dFJlcGxhY2UsICdcXG4gICAgJDEnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmJsb2NrcXVvdGVTZXRleHRSZXBsYWNlMiwgJycpO1xuICAgICAgICAgICAgICAgIHJhdyA9IHJhdyA/IGAke3Jhd31cXG4ke2N1cnJlbnRSYXd9YCA6IGN1cnJlbnRSYXc7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQgPyBgJHt0ZXh0fVxcbiR7Y3VycmVudFRleHR9YCA6IGN1cnJlbnRUZXh0O1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGJsb2NrcXVvdGUgbGluZXMgYXMgdG9wIGxldmVsIHRva2Vuc1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIHBhcmFncmFwaHMgaWYgdGhpcyBpcyBhIGNvbnRpbnVhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMubGV4ZXIuc3RhdGUudG9wO1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGN1cnJlbnRUZXh0LCB0b2tlbnMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdG9wO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGNvbnRpbnVhdGlvbiB0aGVuIHdlIGFyZSBkb25lXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmxvY2txdW90ZSBjb250aW51YXRpb24gY2Fubm90IGJlIHByZWNlZGVkIGJ5IGEgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFzdFRva2VuPy50eXBlID09PSAnYmxvY2txdW90ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBjb250aW51YXRpb24gaW4gbmVzdGVkIGJsb2NrcXVvdGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkVG9rZW4gPSBsYXN0VG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSBvbGRUb2tlbi5yYXcgKyAnXFxuJyArIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUb2tlbiA9IHRoaXMuYmxvY2txdW90ZShuZXdUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9IG5ld1Rva2VuO1xuICAgICAgICAgICAgICAgICAgICByYXcgPSByYXcuc3Vic3RyaW5nKDAsIHJhdy5sZW5ndGggLSBvbGRUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHRleHQubGVuZ3RoIC0gb2xkVG9rZW4udGV4dC5sZW5ndGgpICsgbmV3VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgY29udGludWF0aW9uIGluIG5lc3RlZCBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFRva2VuID0gbGFzdFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gb2xkVG9rZW4ucmF3ICsgJ1xcbicgKyBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VG9rZW4gPSB0aGlzLmxpc3QobmV3VGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPSBuZXdUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gcmF3LnN1YnN0cmluZygwLCByYXcubGVuZ3RoIC0gbGFzdFRva2VuLnJhdy5sZW5ndGgpICsgbmV3VG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sZW5ndGggLSBvbGRUb2tlbi5yYXcubGVuZ3RoKSArIG5ld1Rva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBuZXdUZXh0LnN1YnN0cmluZyh0b2tlbnMuYXQoLTEpLnJhdy5sZW5ndGgpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaXN0KHNyYykge1xuICAgICAgICBsZXQgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IGJ1bGwgPSBjYXBbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGBcXFxcZHsxLDl9XFxcXCR7YnVsbC5zbGljZSgtMSl9YCA6IGBcXFxcJHtidWxsfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGJ1bGwgOiAnWyorLV0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICAgICAgICBjb25zdCBpdGVtUmVnZXggPSB0aGlzLnJ1bGVzLm90aGVyLmxpc3RJdGVtUmVnZXgoYnVsbCk7XG4gICAgICAgICAgICBsZXQgZW5kc1dpdGhCbGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgYnVsbGV0IHBvaW50IGNhbiBzdGFydCBhIG5ldyBMaXN0IEl0ZW1cbiAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kRWFybHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1Db250ZW50cyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLmxpc3RSZXBsYWNlVGFicywgKHQpID0+ICcgJy5yZXBlYXQoMyAqIHQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgYmxhbmtMaW5lID0gIWxpbmUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsxXS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gY2FwWzJdLnNlYXJjaCh0aGlzLnJ1bGVzLm90aGVyLm5vblNwYWNlQ2hhcik7IC8vIEZpbmQgZmlyc3Qgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBjYXBbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lICYmIHRoaXMucnVsZXMub3RoZXIuYmxhbmtMaW5lLnRlc3QobmV4dExpbmUpKSB7IC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IHRoaXMucnVsZXMub3RoZXIubmV4dEJ1bGxldFJlZ2V4KGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSB0aGlzLnJ1bGVzLm90aGVyLmhyUmVnZXgoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVuY2VzQmVnaW5SZWdleCA9IHRoaXMucnVsZXMub3RoZXIuZmVuY2VzQmVnaW5SZWdleChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IHRoaXMucnVsZXMub3RoZXIuaGVhZGluZ0JlZ2luUmVnZXgoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHRtbEJlZ2luUmVnZXggPSB0aGlzLnJ1bGVzLm90aGVyLmh0bWxCZWdpblJlZ2V4KGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lV2l0aG91dFRhYnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IHJhd0xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZS1hbGlnbiB0byBmb2xsb3cgY29tbW9ubWFyayBuZXN0aW5nIHJ1bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXh0TGluZS5yZXBsYWNlKHRoaXMucnVsZXMub3RoZXIubGlzdFJlcGxhY2VOZXN0aW5nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZVdpdGhvdXRUYWJzID0gbmV4dExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZVdpdGhvdXRUYWJzID0gbmV4dExpbmUucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLnRhYkNoYXJHbG9iYWwsICcgICAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIGNvZGUgZmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgaGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIGh0bWwgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodG1sQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgYnVsbGV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEJ1bGxldFJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIHJ1bGUgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExpbmVXaXRob3V0VGFicy5zZWFyY2godGhpcy5ydWxlcy5vdGhlci5ub25TcGFjZUNoYXIpID49IGluZGVudCB8fCAhbmV4dExpbmUudHJpbSgpKSB7IC8vIERlZGVudCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lV2l0aG91dFRhYnMuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJhZ3JhcGggY29udGludWF0aW9uIHVubGVzcyBsYXN0IGxpbmUgd2FzIGEgZGlmZmVyZW50IGJsb2NrIGxldmVsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5yZXBsYWNlKHRoaXMucnVsZXMub3RoZXIudGFiQ2hhckdsb2JhbCwgJyAgICAnKS5zZWFyY2godGhpcy5ydWxlcy5vdGhlci5ub25TcGFjZUNoYXIpID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZVdpdGhvdXRUYWJzLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBpdGVtIGVuZGVkIHdpdGggYSBibGFuayBsaW5lLCB0aGUgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGhCbGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucnVsZXMub3RoZXIuZG91YmxlQmxhbmtMaW5lLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IHRoaXMucnVsZXMub3RoZXIubGlzdElzVGFzay5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci5saXN0UmVwbGFjZVRhc2ssICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaXN0LnJhdyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgY29uc3VtZSBuZXdsaW5lcyBhdCBlbmQgb2YgZmluYWwgaXRlbS4gQWx0ZXJuYXRpdmVseSwgbWFrZSBpdGVtUmVnZXggKnN0YXJ0KiB3aXRoIGFueSBuZXdsaW5lcyB0byBzaW1wbGlmeS9zcGVlZCB1cCBlbmRzV2l0aEJsYW5rTGluZSBsb2dpY1xuICAgICAgICAgICAgY29uc3QgbGFzdEl0ZW0gPSBsaXN0Lml0ZW1zLmF0KC0xKTtcbiAgICAgICAgICAgIGlmIChsYXN0SXRlbSkge1xuICAgICAgICAgICAgICAgIGxhc3RJdGVtLnJhdyA9IGxhc3RJdGVtLnJhdy50cmltRW5kKCk7XG4gICAgICAgICAgICAgICAgbGFzdEl0ZW0udGV4dCA9IGxhc3RJdGVtLnRleHQudHJpbUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgbGlzdCBzaW5jZSB0aGVyZSB3ZXJlIG5vIGl0ZW1zXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5yYXcgPSBsaXN0LnJhdy50cmltRW5kKCk7XG4gICAgICAgICAgICAvLyBJdGVtIGNoaWxkIHRva2VucyBoYW5kbGVkIGhlcmUgYXQgZW5kIGJlY2F1c2Ugd2UgbmVlZGVkIHRvIGhhdmUgdGhlIGZpbmFsIGl0ZW0gdG8gdHJpbSBpdCBmaXJzdFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zW2ldLnRva2VucyA9IHRoaXMubGV4ZXIuYmxvY2tUb2tlbnMobGlzdC5pdGVtc1tpXS50ZXh0LCBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGxpc3Qgc2hvdWxkIGJlIGxvb3NlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNlcnMgPSBsaXN0Lml0ZW1zW2ldLnRva2Vucy5maWx0ZXIodCA9PiB0LnR5cGUgPT09ICdzcGFjZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNNdWx0aXBsZUxpbmVCcmVha3MgPSBzcGFjZXJzLmxlbmd0aCA+IDAgJiYgc3BhY2Vycy5zb21lKHQgPT4gdGhpcy5ydWxlcy5vdGhlci5hbnlMaW5lLnRlc3QodC5yYXcpKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5sb29zZSA9IGhhc011bHRpcGxlTGluZUJyZWFrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgYWxsIGl0ZW1zIHRvIGxvb3NlIGlmIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWwoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBwcmU6IGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWYoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY2FwWzFdLnRvTG93ZXJDYXNlKCkucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm11bHRpcGxlU3BhY2VHbG9iYWwsICcgJyk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci5ocmVmQnJhY2tldHMsICckMScpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zdWJzdHJpbmcoMSwgY2FwWzNdLmxlbmd0aCAtIDEpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogY2FwWzNdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVmJyxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFibGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIWNhcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ydWxlcy5vdGhlci50YWJsZURlbGltaXRlci50ZXN0KGNhcFsyXSkpIHtcbiAgICAgICAgICAgIC8vIGRlbGltaXRlciByb3cgbXVzdCBoYXZlIGEgcGlwZSAofCkgb3IgY29sb24gKDopIG90aGVyd2lzZSBpdCBpcyBhIHNldGV4dCBoZWFkaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHNwbGl0Q2VsbHMoY2FwWzFdKTtcbiAgICAgICAgY29uc3QgYWxpZ25zID0gY2FwWzJdLnJlcGxhY2UodGhpcy5ydWxlcy5vdGhlci50YWJsZUFsaWduQ2hhcnMsICcnKS5zcGxpdCgnfCcpO1xuICAgICAgICBjb25zdCByb3dzID0gY2FwWzNdPy50cmltKCkgPyBjYXBbM10ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLnRhYmxlUm93QmxhbmtMaW5lLCAnJykuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICBoZWFkZXI6IFtdLFxuICAgICAgICAgICAgYWxpZ246IFtdLFxuICAgICAgICAgICAgcm93czogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCAhPT0gYWxpZ25zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gaGVhZGVyIGFuZCBhbGlnbiBjb2x1bW5zIG11c3QgYmUgZXF1YWwsIHJvd3MgY2FuIGJlIGRpZmZlcmVudC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFsaWduIG9mIGFsaWducykge1xuICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMub3RoZXIudGFibGVBbGlnblJpZ2h0LnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hbGlnbi5wdXNoKCdyaWdodCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5ydWxlcy5vdGhlci50YWJsZUFsaWduQ2VudGVyLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hbGlnbi5wdXNoKCdjZW50ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucnVsZXMub3RoZXIudGFibGVBbGlnbkxlZnQudGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0uaGVhZGVyLnB1c2goe1xuICAgICAgICAgICAgICAgIHRleHQ6IGhlYWRlcnNbaV0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShoZWFkZXJzW2ldKSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgYWxpZ246IGl0ZW0uYWxpZ25baV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3MucHVzaChzcGxpdENlbGxzKHJvdywgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoKGNlbGwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjZWxsLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNlbGwpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbjogaXRlbS5hbGlnbltpXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBsaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saGVhZGluZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBjYXBbMl0uY2hhckF0KDApID09PSAnPScgPyAxIDogMixcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjYXBbMV0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sucGFyYWdyYXBoLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNhcFsxXS5jaGFyQXQoY2FwWzFdLmxlbmd0aCAtIDEpID09PSAnXFxuJ1xuICAgICAgICAgICAgICAgID8gY2FwWzFdLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgICAgIDogY2FwWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmUodGV4dCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRleHQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVzY2FwZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZXNjYXBlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXNjYXBlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiB0aGlzLnJ1bGVzLm90aGVyLnN0YXJ0QVRhZy50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiB0aGlzLnJ1bGVzLm90aGVyLmVuZEFUYWcudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIHRoaXMucnVsZXMub3RoZXIuc3RhcnRQcmVTY3JpcHRUYWcudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayAmJiB0aGlzLnJ1bGVzLm90aGVyLmVuZFByZVNjcmlwdFRhZy50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGluTGluazogdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmssXG4gICAgICAgICAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmsoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmxpbmsuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkVXJsID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnBlZGFudGljICYmIHRoaXMucnVsZXMub3RoZXIuc3RhcnRBbmdsZUJyYWNrZXQudGVzdCh0cmltbWVkVXJsKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbW1vbm1hcmsgcmVxdWlyZXMgbWF0Y2hpbmcgYW5nbGUgYnJhY2tldHNcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnJ1bGVzLm90aGVyLmVuZEFuZ2xlQnJhY2tldC50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLnJ1bGVzLm90aGVyLnBlZGFudGljSHJlZlRpdGxlLmV4ZWMoaHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bGVzLm90aGVyLnN0YXJ0QW5nbGVCcmFja2V0LnRlc3QoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEodGhpcy5ydWxlcy5vdGhlci5lbmRBbmdsZUJyYWNrZXQudGVzdCh0cmltbWVkVXJsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVkYW50aWMgYWxsb3dzIHN0YXJ0aW5nIGFuZ2xlIGJyYWNrZXQgd2l0aG91dCBlbmRpbmcgYW5nbGUgYnJhY2tldFxuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgICAgICAgICBocmVmOiBocmVmID8gaHJlZi5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLCAnJDEnKSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlID8gdGl0bGUucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiB0aXRsZSxcbiAgICAgICAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlciwgdGhpcy5ydWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtTdHJpbmcgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm11bHRpcGxlU3BhY2VHbG9iYWwsICcgJyk7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gbGlua3NbbGlua1N0cmluZy50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlciwgdGhpcy5ydWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdMRGVsaW0uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBfIGNhbid0IGJlIGJldHdlZW4gdHdvIGFscGhhbnVtZXJpY3MuIFxccHtMfVxccHtOfSBpbmNsdWRlcyBub24tZW5nbGlzaCBhbHBoYWJldC9udW1iZXJzIGFzIHdlbGxcbiAgICAgICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKHRoaXMucnVsZXMub3RoZXIudW5pY29kZUFscGhhTnVtZXJpYykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgJyc7XG4gICAgICAgIGlmICghbmV4dENoYXIgfHwgIXByZXZDaGFyIHx8IHRoaXMucnVsZXMuaW5saW5lLnB1bmN0dWF0aW9uLmV4ZWMocHJldkNoYXIpKSB7XG4gICAgICAgICAgICAvLyB1bmljb2RlIFJlZ2V4IGNvdW50cyBlbW9qaSBhcyAxIGNoYXI7IHNwcmVhZCBpbnRvIGFycmF5IGZvciBwcm9wZXIgY291bnQgKHVzZWQgbXVsdGlwbGUgdGltZXMgYmVsb3cpXG4gICAgICAgICAgICBjb25zdCBsTGVuZ3RoID0gWy4uLm1hdGNoWzBdXS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IHJEZWxpbSwgckxlbmd0aCwgZGVsaW1Ub3RhbCA9IGxMZW5ndGgsIG1pZERlbGltVG90YWwgPSAwO1xuICAgICAgICAgICAgY29uc3QgZW5kUmVnID0gbWF0Y2hbMF1bMF0gPT09ICcqJyA/IHRoaXMucnVsZXMuaW5saW5lLmVtU3Ryb25nUkRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdSRGVsaW1VbmQ7XG4gICAgICAgICAgICBlbmRSZWcubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIENsaXAgbWFza2VkU3JjIHRvIHNhbWUgc2VjdGlvbiBvZiBzdHJpbmcgYXMgc3JjIChtb3ZlIHRvIGxleGVyPylcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgtMSAqIHNyYy5sZW5ndGggKyBsTGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgckRlbGltID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMl0gfHwgbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgbWF0Y2hbNl07XG4gICAgICAgICAgICAgICAgaWYgKCFyRGVsaW0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHNpbmdsZSAqIGluIF9fYWJjKmFiY19fXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IFsuLi5yRGVsaW1dLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbM10gfHwgbWF0Y2hbNF0pIHsgLy8gZm91bmQgYW5vdGhlciBMZWZ0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGRlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzVdIHx8IG1hdGNoWzZdKSB7IC8vIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltXG4gICAgICAgICAgICAgICAgICAgIGlmIChsTGVuZ3RoICUgMyAmJiAhKChsTGVuZ3RoICsgckxlbmd0aCkgJSAzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkRGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIENvbW1vbk1hcmsgRW1waGFzaXMgUnVsZXMgOS0xMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGltVG90YWwgLT0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsaW1Ub3RhbCA+IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBIYXZlbid0IGZvdW5kIGVub3VnaCBjbG9zaW5nIGRlbGltaXRlcnNcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXh0cmEgY2hhcmFjdGVycy4gKmEqKiogLT4gKmEqXG4gICAgICAgICAgICAgICAgckxlbmd0aCA9IE1hdGgubWluKHJMZW5ndGgsIHJMZW5ndGggKyBkZWxpbVRvdGFsICsgbWlkRGVsaW1Ub3RhbCk7XG4gICAgICAgICAgICAgICAgLy8gY2hhciBsZW5ndGggY2FuIGJlID4xIGZvciB1bmljb2RlIGNoYXJhY3RlcnM7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXJMZW5ndGggPSBbLi4ubWF0Y2hbMF1dWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBzcmMuc2xpY2UoMCwgbExlbmd0aCArIG1hdGNoLmluZGV4ICsgbGFzdENoYXJMZW5ndGggKyByTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYGVtYCBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIG9kZCBjaGFyIGNvdW50LiAqYSoqKlxuICAgICAgICAgICAgICAgIGlmIChNYXRoLm1pbihsTGVuZ3RoLCByTGVuZ3RoKSAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSAnc3Ryb25nJyBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIGV2ZW4gY2hhciBjb3VudC4gKiphKioqXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgyLCAtMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGVzcGFuKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSh0aGlzLnJ1bGVzLm90aGVyLm5ld0xpbmVDaGFyR2xvYmFsLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgaGFzTm9uU3BhY2VDaGFycyA9IHRoaXMucnVsZXMub3RoZXIubm9uU3BhY2VDaGFyLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IHRoaXMucnVsZXMub3RoZXIuc3RhcnRpbmdTcGFjZUNoYXIudGVzdCh0ZXh0KSAmJiB0aGlzLnJ1bGVzLm90aGVyLmVuZGluZ1NwYWNlQ2hhci50ZXN0KHRleHQpO1xuICAgICAgICAgICAgaWYgKGhhc05vblNwYWNlQ2hhcnMgJiYgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGVzcGFuJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBicihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdicicsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2VucyhjYXBbMl0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdXRvbGluayhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYXV0b2xpbmsuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBjYXBbMV07XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gY2FwWzFdO1xuICAgICAgICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybChzcmMpIHtcbiAgICAgICAgbGV0IGNhcDtcbiAgICAgICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnVybC5leGVjKHNyYykpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGNhcFswXTtcbiAgICAgICAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgIGxldCBwcmV2Q2FwWmVybztcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSB0aGlzLnJ1bGVzLmlubGluZS5fYmFja3BlZGFsLmV4ZWMoY2FwWzBdKT8uWzBdID8/ICcnO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZDYXBaZXJvICE9PSBjYXBbMF0pO1xuICAgICAgICAgICAgICAgIHRleHQgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVUZXh0KHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgZXNjYXBlZCA9IHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jaztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBlc2NhcGVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCbG9jayBMZXhlclxuICovXG5jbGFzcyBfTGV4ZXIge1xuICAgIHRva2VucztcbiAgICBvcHRpb25zO1xuICAgIHN0YXRlO1xuICAgIHRva2VuaXplcjtcbiAgICBpbmxpbmVRdWV1ZTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8vIFRva2VuTGlzdCBjYW5ub3QgYmUgY3JlYXRlZCBpbiBvbmUgZ29cbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMubGlua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICAgICAgdGhpcy5vcHRpb25zLnRva2VuaXplciA9IHRoaXMub3B0aW9ucy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIoKTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyO1xuICAgICAgICB0aGlzLnRva2VuaXplci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnRva2VuaXplci5sZXhlciA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGluTGluazogZmFsc2UsXG4gICAgICAgICAgICBpblJhd0Jsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgIHRvcDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICAgICAgICBvdGhlcixcbiAgICAgICAgICAgIGJsb2NrOiBibG9jay5ub3JtYWwsXG4gICAgICAgICAgICBpbmxpbmU6IGlubGluZS5ub3JtYWwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBSdWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGlubGluZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4KHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIGxleElubGluZShzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGV4ZXIgPSBuZXcgX0xleGVyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbGV4ZXIuaW5saW5lVG9rZW5zKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXByb2Nlc3NpbmdcbiAgICAgKi9cbiAgICBsZXgoc3JjKSB7XG4gICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKG90aGVyLmNhcnJpYWdlUmV0dXJuLCAnXFxuJyk7XG4gICAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5saW5lUXVldWVbaV07XG4gICAgICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdLCBsYXN0UGFyYWdyYXBoQ2xpcHBlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKG90aGVyLnRhYkNoYXJHbG9iYWwsICcgICAgJykucmVwbGFjZShvdGhlci5zcGFjZUxpbmUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBsZXQgdG9rZW47XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LmJsb2NrPy5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmF3Lmxlbmd0aCA9PT0gMSAmJiBsYXN0VG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgc2luZ2xlIFxcbiBhcyBhIHNwYWNlciwgaXQncyB0ZXJtaW5hdGluZyB0aGUgbGFzdCBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBtb3ZlIGl0IHRoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IHVubmVjZXNzYXJ5IHBhcmFncmFwaCB0YWdzXG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICAgICAgICAgIC8vIEFuIGluZGVudGVkIGNvZGUgYmxvY2sgY2Fubm90IGludGVycnVwdCBhIHBhcmFncmFwaC5cbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4/LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZlbmNlc1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJsb2NrcXVvdGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlzdFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBodG1sXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZlxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IHRva2Vucy5hdCgtMSk7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbj8udHlwZSA9PT0gJ3BhcmFncmFwaCcgfHwgbGFzdFRva2VuPy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFibGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxoZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICAgICAgICAgIC8vIHByZXZlbnQgcGFyYWdyYXBoIGNvbnN1bWluZyBleHRlbnNpb25zIGJ5IGNsaXBwaW5nICdzcmMnIHRvIGV4dGVuc2lvbiBzdGFydFxuICAgICAgICAgICAgbGV0IGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucz8uc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2suZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4/LnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5hdCgtMSkuc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGV4dFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0VG9rZW4gPSB0b2tlbnMuYXQoLTEpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4/LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUuYXQoLTEpLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGlubGluZShzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICAgICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUucmVmbGlua1NlYXJjaC5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXNrIG91dCBlc2NhcGVkIGNoYXJhY3RlcnNcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbi5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnKysnICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbi5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrZWVwUHJldkNoYXIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHByZXZDaGFyID0gJyc7XG4gICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgIGlmICgha2VlcFByZXZDaGFyKSB7XG4gICAgICAgICAgICAgICAgcHJldkNoYXIgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtlZXBQcmV2Q2hhciA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICAgICAgLy8gZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zPy5pbmxpbmU/LnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbj8udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiclxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0b2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjKSkpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIC8vIHByZXZlbnQgaW5saW5lVGV4dCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGxldCBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUuZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoY3V0U3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5zbGljZSgtMSkgIT09ICdfJykgeyAvLyBUcmFjayBwcmV2Q2hhciBiZWZvcmUgc3RyaW5nIG9mIF9fX18gc3RhcnRlZFxuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hhciA9IHRva2VuLnJhdy5zbGljZSgtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtlZXBQcmV2Q2hhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFRva2VuID0gdG9rZW5zLmF0KC0xKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuPy50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcmVyXG4gKi9cbmNsYXNzIF9SZW5kZXJlciB7XG4gICAgb3B0aW9ucztcbiAgICBwYXJzZXI7IC8vIHNldCBieSB0aGUgcGFyc2VyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3BhY2UodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb2RlKHsgdGV4dCwgbGFuZywgZXNjYXBlZCB9KSB7XG4gICAgICAgIGNvbnN0IGxhbmdTdHJpbmcgPSAobGFuZyB8fCAnJykubWF0Y2gob3RoZXIubm90U3BhY2VTdGFydCk/LlswXTtcbiAgICAgICAgY29uc3QgY29kZSA9IHRleHQucmVwbGFjZShvdGhlci5lbmRpbmdOZXdsaW5lLCAnJykgKyAnXFxuJztcbiAgICAgICAgaWYgKCFsYW5nU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLSdcbiAgICAgICAgICAgICsgZXNjYXBlKGxhbmdTdHJpbmcpXG4gICAgICAgICAgICArICdcIj4nXG4gICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBibG9ja3F1b3RlKHsgdG9rZW5zIH0pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2VyLnBhcnNlKHRva2Vucyk7XG4gICAgICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtib2R5fTwvYmxvY2txdW90ZT5cXG5gO1xuICAgIH1cbiAgICBodG1sKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBoZWFkaW5nKHsgdG9rZW5zLCBkZXB0aCB9KSB7XG4gICAgICAgIHJldHVybiBgPGgke2RlcHRofT4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9oJHtkZXB0aH0+XFxuYDtcbiAgICB9XG4gICAgaHIodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgbGlzdCh0b2tlbikge1xuICAgICAgICBjb25zdCBvcmRlcmVkID0gdG9rZW4ub3JkZXJlZDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0b2tlbi5zdGFydDtcbiAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbi5pdGVtcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgYm9keSArPSB0aGlzLmxpc3RpdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gICAgICAgIGNvbnN0IHN0YXJ0QXR0ciA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydEF0dHIgKyAnPlxcbicgKyBib2R5ICsgJzwvJyArIHR5cGUgKyAnPlxcbic7XG4gICAgfVxuICAgIGxpc3RpdGVtKGl0ZW0pIHtcbiAgICAgICAgbGV0IGl0ZW1Cb2R5ID0gJyc7XG4gICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gdGhpcy5jaGVja2JveCh7IGNoZWNrZWQ6ICEhaXRlbS5jaGVja2VkIH0pO1xuICAgICAgICAgICAgaWYgKGl0ZW0ubG9vc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0/LnR5cGUgPT09ICdwYXJhZ3JhcGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vuc1swXS50b2tlbnMgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGVzY2FwZShpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiBjaGVja2JveCArICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNoZWNrYm94ICsgJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgKz0gY2hlY2tib3ggKyAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXRlbUJvZHkgKz0gdGhpcy5wYXJzZXIucGFyc2UoaXRlbS50b2tlbnMsICEhaXRlbS5sb29zZSk7XG4gICAgICAgIHJldHVybiBgPGxpPiR7aXRlbUJvZHl9PC9saT5cXG5gO1xuICAgIH1cbiAgICBjaGVja2JveCh7IGNoZWNrZWQgfSkge1xuICAgICAgICByZXR1cm4gJzxpbnB1dCAnXG4gICAgICAgICAgICArIChjaGVja2VkID8gJ2NoZWNrZWQ9XCJcIiAnIDogJycpXG4gICAgICAgICAgICArICdkaXNhYmxlZD1cIlwiIHR5cGU9XCJjaGVja2JveFwiPic7XG4gICAgfVxuICAgIHBhcmFncmFwaCh7IHRva2VucyB9KSB7XG4gICAgICAgIHJldHVybiBgPHA+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvcD5cXG5gO1xuICAgIH1cbiAgICB0YWJsZSh0b2tlbikge1xuICAgICAgICBsZXQgaGVhZGVyID0gJyc7XG4gICAgICAgIC8vIGhlYWRlclxuICAgICAgICBsZXQgY2VsbCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2VuLmhlYWRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY2VsbCArPSB0aGlzLnRhYmxlY2VsbCh0b2tlbi5oZWFkZXJbal0pO1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlciArPSB0aGlzLnRhYmxlcm93KHsgdGV4dDogY2VsbCB9KTtcbiAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0b2tlbi5yb3dzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSB0b2tlbi5yb3dzW2pdO1xuICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMudGFibGVjZWxsKHJvd1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5ICs9IHRoaXMudGFibGVyb3coeyB0ZXh0OiBjZWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5KVxuICAgICAgICAgICAgYm9keSA9IGA8dGJvZHk+JHtib2R5fTwvdGJvZHk+YDtcbiAgICAgICAgcmV0dXJuICc8dGFibGU+XFxuJ1xuICAgICAgICAgICAgKyAnPHRoZWFkPlxcbidcbiAgICAgICAgICAgICsgaGVhZGVyXG4gICAgICAgICAgICArICc8L3RoZWFkPlxcbidcbiAgICAgICAgICAgICsgYm9keVxuICAgICAgICAgICAgKyAnPC90YWJsZT5cXG4nO1xuICAgIH1cbiAgICB0YWJsZXJvdyh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gYDx0cj5cXG4ke3RleHR9PC90cj5cXG5gO1xuICAgIH1cbiAgICB0YWJsZWNlbGwodG9rZW4pIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VuLnRva2Vucyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0b2tlbi5oZWFkZXIgPyAndGgnIDogJ3RkJztcbiAgICAgICAgY29uc3QgdGFnID0gdG9rZW4uYWxpZ25cbiAgICAgICAgICAgID8gYDwke3R5cGV9IGFsaWduPVwiJHt0b2tlbi5hbGlnbn1cIj5gXG4gICAgICAgICAgICA6IGA8JHt0eXBlfT5gO1xuICAgICAgICByZXR1cm4gdGFnICsgY29udGVudCArIGA8LyR7dHlwZX0+XFxuYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3BhbiBsZXZlbCByZW5kZXJlclxuICAgICAqL1xuICAgIHN0cm9uZyh7IHRva2VucyB9KSB7XG4gICAgICAgIHJldHVybiBgPHN0cm9uZz4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9zdHJvbmc+YDtcbiAgICB9XG4gICAgZW0oeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxlbT4ke3RoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyl9PC9lbT5gO1xuICAgIH1cbiAgICBjb2Rlc3Bhbih7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gYDxjb2RlPiR7ZXNjYXBlKHRleHQsIHRydWUpfTwvY29kZT5gO1xuICAgIH1cbiAgICBicih0b2tlbikge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwoeyB0b2tlbnMgfSkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0aGlzLnBhcnNlci5wYXJzZUlubGluZSh0b2tlbnMpfTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoeyBocmVmLCB0aXRsZSwgdG9rZW5zIH0pIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gJzxhIGhyZWY9XCInICsgaHJlZiArICdcIic7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgKGVzY2FwZSh0aXRsZSkpICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJz4nICsgdGV4dCArICc8L2E+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgaW1hZ2UoeyBocmVmLCB0aXRsZSwgdGV4dCB9KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSBgPGltZyBzcmM9XCIke2hyZWZ9XCIgYWx0PVwiJHt0ZXh0fVwiYDtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gYCB0aXRsZT1cIiR7ZXNjYXBlKHRpdGxlKX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdGV4dCh0b2tlbikge1xuICAgICAgICByZXR1cm4gJ3Rva2VucycgaW4gdG9rZW4gJiYgdG9rZW4udG9rZW5zXG4gICAgICAgICAgICA/IHRoaXMucGFyc2VyLnBhcnNlSW5saW5lKHRva2VuLnRva2VucylcbiAgICAgICAgICAgIDogKCdlc2NhcGVkJyBpbiB0b2tlbiAmJiB0b2tlbi5lc2NhcGVkID8gdG9rZW4udGV4dCA6IGVzY2FwZSh0b2tlbi50ZXh0KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh7IHRleHQgfSkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZW0oeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGNvZGVzcGFuKHsgdGV4dCB9KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGh0bWwoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHRleHQoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoeyB0ZXh0IH0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5jbGFzcyBfUGFyc2VyIHtcbiAgICBvcHRpb25zO1xuICAgIHJlbmRlcmVyO1xuICAgIHRleHRSZW5kZXJlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucGFyc2VyID0gdGhpcztcbiAgICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgX1RleHRSZW5kZXJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgX1BhcnNlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUlubGluZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgTG9vcFxuICAgICAqL1xuICAgIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbnlUb2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zPy5yZW5kZXJlcnM/LlthbnlUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyaWNUb2tlbiA9IGFueVRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1tnZW5lcmljVG9rZW4udHlwZV0uY2FsbCh7IHBhcnNlcjogdGhpcyB9LCBnZW5lcmljVG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ3NwYWNlJywgJ2hyJywgJ2hlYWRpbmcnLCAnY29kZScsICd0YWJsZScsICdibG9ja3F1b3RlJywgJ2xpc3QnLCAnaHRtbCcsICdwYXJhZ3JhcGgnLCAndGV4dCddLmluY2x1ZGVzKGdlbmVyaWNUb2tlbi50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmV0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGFueVRva2VuO1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnNwYWNlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ocih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGlzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSB0aGlzLnJlbmRlcmVyLnRleHQodGV4dFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgdGhpcy5yZW5kZXJlci50ZXh0KHRleHRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFt7IHR5cGU6ICd0ZXh0JywgcmF3OiBib2R5LCB0ZXh0OiBib2R5LCBlc2NhcGVkOiB0cnVlIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgSW5saW5lIFRva2Vuc1xuICAgICAqL1xuICAgIHBhcnNlSW5saW5lKHRva2VucywgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFueVRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnM/LnJlbmRlcmVycz8uW2FueVRva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2FueVRva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgYW55VG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXMoYW55VG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSBhbnlUb2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluayc6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmxpbmsodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1hZ2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzdHJvbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5zdHJvbmcodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmNvZGVzcGFuKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuYnIodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZGVsKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuXG5jbGFzcyBfSG9va3Mge1xuICAgIG9wdGlvbnM7XG4gICAgYmxvY2s7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3RhdGljIHBhc3NUaHJvdWdoSG9va3MgPSBuZXcgU2V0KFtcbiAgICAgICAgJ3ByZXByb2Nlc3MnLFxuICAgICAgICAncG9zdHByb2Nlc3MnLFxuICAgICAgICAncHJvY2Vzc0FsbFRva2VucycsXG4gICAgXSk7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAgICovXG4gICAgcHJlcHJvY2VzcyhtYXJrZG93bikge1xuICAgICAgICByZXR1cm4gbWFya2Rvd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgSFRNTCBhZnRlciBtYXJrZWQgaXMgZmluaXNoZWRcbiAgICAgKi9cbiAgICBwb3N0cHJvY2VzcyhodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCB0b2tlbnMgYmVmb3JlIHdhbGsgdG9rZW5zXG4gICAgICovXG4gICAgcHJvY2Vzc0FsbFRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBmdW5jdGlvbiB0byB0b2tlbml6ZSBtYXJrZG93blxuICAgICAqL1xuICAgIHByb3ZpZGVMZXhlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sgPyBfTGV4ZXIubGV4IDogX0xleGVyLmxleElubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBmdW5jdGlvbiB0byBwYXJzZSB0b2tlbnNcbiAgICAgKi9cbiAgICBwcm92aWRlUGFyc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayA/IF9QYXJzZXIucGFyc2UgOiBfUGFyc2VyLnBhcnNlSW5saW5lO1xuICAgIH1cbn1cblxuY2xhc3MgTWFya2VkIHtcbiAgICBkZWZhdWx0cyA9IF9nZXREZWZhdWx0cygpO1xuICAgIG9wdGlvbnMgPSB0aGlzLnNldE9wdGlvbnM7XG4gICAgcGFyc2UgPSB0aGlzLnBhcnNlTWFya2Rvd24odHJ1ZSk7XG4gICAgcGFyc2VJbmxpbmUgPSB0aGlzLnBhcnNlTWFya2Rvd24oZmFsc2UpO1xuICAgIFBhcnNlciA9IF9QYXJzZXI7XG4gICAgUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG4gICAgVGV4dFJlbmRlcmVyID0gX1RleHRSZW5kZXJlcjtcbiAgICBMZXhlciA9IF9MZXhlcjtcbiAgICBUb2tlbml6ZXIgPSBfVG9rZW5pemVyO1xuICAgIEhvb2tzID0gX0hvb2tzO1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy51c2UoLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAgICAgKi9cbiAgICB3YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChjYWxsYmFjay5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGFibGVUb2tlbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlVG9rZW4ucm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMobGlzdFRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucz8uY2hpbGRUb2tlbnM/LltnZW5lcmljVG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tnZW5lcmljVG9rZW4udHlwZV0uZm9yRWFjaCgoY2hpbGRUb2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBnZW5lcmljVG9rZW5bY2hpbGRUb2tlbnNdLmZsYXQoSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdlbmVyaWNUb2tlbi50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGdlbmVyaWNUb2tlbi50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgdXNlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucyB8fCB7IHJlbmRlcmVyczoge30sIGNoaWxkVG9rZW5zOiB7fSB9O1xuICAgICAgICBhcmdzLmZvckVhY2goKHBhY2spID0+IHtcbiAgICAgICAgICAgIC8vIGNvcHkgb3B0aW9ucyB0byBuZXcgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBvcHRzID0geyAuLi5wYWNrIH07XG4gICAgICAgICAgICAvLyBzZXQgYXN5bmMgdG8gdHJ1ZSBpZiBpdCB3YXMgc2V0IHRvIHRydWUgYmVmb3JlXG4gICAgICAgICAgICBvcHRzLmFzeW5jID0gdGhpcy5kZWZhdWx0cy5hc3luYyB8fCBvcHRzLmFzeW5jIHx8IGZhbHNlO1xuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcImFkZG9uXCIgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcGFjay5leHRlbnNpb25zLmZvckVhY2goKGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuc2lvbiBuYW1lIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdyZW5kZXJlcicgaW4gZXh0KSB7IC8vIFJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2UmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGV4dGVuc2lvbiB3aXRoIGZ1bmMgdG8gcnVuIG5ldyBleHRlbnNpb24gYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMucmVuZGVyZXJzW2V4dC5uYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBleHQucmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZXh0LnJlbmRlcmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgndG9rZW5pemVyJyBpbiBleHQpIHsgLy8gVG9rZW5pemVyIEV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXh0LmxldmVsIHx8IChleHQubGV2ZWwgIT09ICdibG9jaycgJiYgZXh0LmxldmVsICE9PSAnaW5saW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHRlbnNpb24gbGV2ZWwgbXVzdCBiZSAnYmxvY2snIG9yICdpbmxpbmUnXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0TGV2ZWwgPSBleHRlbnNpb25zW2V4dC5sZXZlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRMZXZlbC51bnNoaWZ0KGV4dC50b2tlbml6ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHQubGV2ZWxdID0gW2V4dC50b2tlbml6ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5zdGFydCkgeyAvLyBGdW5jdGlvbiB0byBjaGVjayBmb3Igc3RhcnQgb2YgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LmxldmVsID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jay5wdXNoKGV4dC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0QmxvY2sgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHQubGV2ZWwgPT09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb25zLnN0YXJ0SW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnN0YXJ0SW5saW5lLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUgPSBbZXh0LnN0YXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ2NoaWxkVG9rZW5zJyBpbiBleHQgJiYgZXh0LmNoaWxkVG9rZW5zKSB7IC8vIENoaWxkIHRva2VucyB0byBiZSB2aXNpdGVkIGJ5IHdhbGtUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuY2hpbGRUb2tlbnNbZXh0Lm5hbWVdID0gZXh0LmNoaWxkVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3B0cy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgXCJvdmVyd3JpdGVcIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSB0aGlzLmRlZmF1bHRzLnJlbmRlcmVyIHx8IG5ldyBfUmVuZGVyZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiByZW5kZXJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVuZGVyZXIgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdwYXJzZXInXS5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG9wdGlvbnMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyUHJvcCA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyRnVuYyA9IHBhY2sucmVuZGVyZXJbcmVuZGVyZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gcmVuZGVyZXJbcmVuZGVyZXJQcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcltyZW5kZXJlclByb3BdID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSByZW5kZXJlckZ1bmMuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2UmVuZGVyZXIuYXBwbHkocmVuZGVyZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyID0gdGhpcy5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IF9Ub2tlbml6ZXIodGhpcy5kZWZhdWx0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2sudG9rZW5pemVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gdG9rZW5pemVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0b2tlbml6ZXIgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdydWxlcycsICdsZXhlciddLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucywgcnVsZXMsIGFuZCBsZXhlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyRnVuYyA9IHBhY2sudG9rZW5pemVyW3Rva2VuaXplclByb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2VG9rZW5pemVyID0gdG9rZW5pemVyW3Rva2VuaXplclByb3BdO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRva2VuaXplciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbm5vdCB0eXBlIHRva2VuaXplciBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICB0b2tlbml6ZXJbdG9rZW5pemVyUHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHRva2VuaXplckZ1bmMuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldlRva2VuaXplci5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIEhvb2tzIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2suaG9va3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rcyA9IHRoaXMuZGVmYXVsdHMuaG9va3MgfHwgbmV3IF9Ib29rcygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgaW4gaG9va3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhvb2sgJyR7cHJvcH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKFsnb3B0aW9ucycsICdibG9jayddLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucyBhbmQgYmxvY2sgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NGdW5jID0gcGFjay5ob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2SG9vayA9IGhvb2tzW2hvb2tzUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGhvb2tzRnVuYy5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFdhbGtUb2tlbnMgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Fsa1Rva2VucyA9IHRoaXMuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrV2Fsa3Rva2VucyA9IHBhY2sud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrV2Fsa3Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdHMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHQgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxleGVyKHNyYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX0xleGVyLmxleChzcmMsIG9wdGlvbnMgPz8gdGhpcy5kZWZhdWx0cyk7XG4gICAgfVxuICAgIHBhcnNlcih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9QYXJzZXIucGFyc2UodG9rZW5zLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICBwYXJzZU1hcmtkb3duKGJsb2NrVHlwZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYXJzZSA9IChzcmMsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdPcHQgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3JpZ09wdCB9O1xuICAgICAgICAgICAgY29uc3QgdGhyb3dFcnJvciA9IHRoaXMub25FcnJvcighIW9wdC5zaWxlbnQsICEhb3B0LmFzeW5jKTtcbiAgICAgICAgICAgIC8vIHRocm93IGVycm9yIGlmIGFuIGV4dGVuc2lvbiBzZXQgYXN5bmMgdG8gdHJ1ZSBidXQgcGFyc2Ugd2FzIGNhbGxlZCB3aXRoIGFzeW5jOiBmYWxzZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMgPT09IHRydWUgJiYgb3JpZ09wdC5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBUaGUgYXN5bmMgb3B0aW9uIHdhcyBzZXQgdG8gdHJ1ZSBieSBhbiBleHRlbnNpb24uIFJlbW92ZSBhc3luYzogZmFsc2UgZnJvbSB0aGUgcGFyc2Ugb3B0aW9ucyBvYmplY3QgdG8gcmV0dXJuIGEgUHJvbWlzZS4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICAgICAgICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLmJsb2NrID0gYmxvY2tUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGV4ZXIgPSBvcHQuaG9va3MgPyBvcHQuaG9va3MucHJvdmlkZUxleGVyKCkgOiAoYmxvY2tUeXBlID8gX0xleGVyLmxleCA6IF9MZXhlci5sZXhJbmxpbmUpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb3ZpZGVQYXJzZXIoKSA6IChibG9ja1R5cGUgPyBfUGFyc2VyLnBhcnNlIDogX1BhcnNlci5wYXJzZUlubGluZSk7XG4gICAgICAgICAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzcmMgPT4gbGV4ZXIoc3JjLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKSA6IHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFyc2U7XG4gICAgfVxuICAgIG9uRXJyb3Ioc2lsZW50LCBhc3luYykge1xuICAgICAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgICAgICAgIGUubWVzc2FnZSArPSAnXFxuUGxlYXNlIHJlcG9ydCB0aGlzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWQuJztcbiAgICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+J1xuICAgICAgICAgICAgICAgICAgICArIGVzY2FwZShlLm1lc3NhZ2UgKyAnJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgKyAnPC9wcmU+JztcbiAgICAgICAgICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNvbnN0IG1hcmtlZEluc3RhbmNlID0gbmV3IE1hcmtlZCgpO1xuZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0KSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLnBhcnNlKHNyYywgb3B0KTtcbn1cbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9uc1xuICovXG5tYXJrZWQub3B0aW9ucyA9XG4gICAgbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBtYXJrZWRJbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgICAgICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlZDtcbiAgICB9O1xuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHM7XG5tYXJrZWQuZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG4vKipcbiAqIFVzZSBFeHRlbnNpb25cbiAqL1xubWFya2VkLnVzZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbWFya2VkSW5zdGFuY2UudXNlKC4uLmFyZ3MpO1xuICAgIG1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZEluc3RhbmNlLmRlZmF1bHRzO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbn07XG4vKipcbiAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAqL1xubWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS53YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQ29tcGlsZXMgbWFya2Rvd24gdG8gSFRNTCB3aXRob3V0IGVuY2xvc2luZyBgcGAgdGFnLlxuICpcbiAqIEBwYXJhbSBzcmMgU3RyaW5nIG9mIG1hcmtkb3duIHNvdXJjZSB0byBiZSBjb21waWxlZFxuICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zXG4gKiBAcmV0dXJuIFN0cmluZyBvZiBjb21waWxlZCBIVE1MXG4gKi9cbm1hcmtlZC5wYXJzZUlubGluZSA9IG1hcmtlZEluc3RhbmNlLnBhcnNlSW5saW5lO1xuLyoqXG4gKiBFeHBvc2VcbiAqL1xubWFya2VkLlBhcnNlciA9IF9QYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbm1hcmtlZC5SZW5kZXJlciA9IF9SZW5kZXJlcjtcbm1hcmtlZC5UZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gX0xleGVyO1xubWFya2VkLmxleGVyID0gX0xleGVyLmxleDtcbm1hcmtlZC5Ub2tlbml6ZXIgPSBfVG9rZW5pemVyO1xubWFya2VkLkhvb2tzID0gX0hvb2tzO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuY29uc3Qgb3B0aW9ucyA9IG1hcmtlZC5vcHRpb25zO1xuY29uc3Qgc2V0T3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zO1xuY29uc3QgdXNlID0gbWFya2VkLnVzZTtcbmNvbnN0IHdhbGtUb2tlbnMgPSBtYXJrZWQud2Fsa1Rva2VucztcbmNvbnN0IHBhcnNlSW5saW5lID0gbWFya2VkLnBhcnNlSW5saW5lO1xuY29uc3QgcGFyc2UgPSBtYXJrZWQ7XG5jb25zdCBwYXJzZXIgPSBfUGFyc2VyLnBhcnNlO1xuY29uc3QgbGV4ZXIgPSBfTGV4ZXIubGV4O1xuXG5leHBvcnQgeyBfSG9va3MgYXMgSG9va3MsIF9MZXhlciBhcyBMZXhlciwgTWFya2VkLCBfUGFyc2VyIGFzIFBhcnNlciwgX1JlbmRlcmVyIGFzIFJlbmRlcmVyLCBfVGV4dFJlbmRlcmVyIGFzIFRleHRSZW5kZXJlciwgX1Rva2VuaXplciBhcyBUb2tlbml6ZXIsIF9kZWZhdWx0cyBhcyBkZWZhdWx0cywgX2dldERlZmF1bHRzIGFzIGdldERlZmF1bHRzLCBsZXhlciwgbWFya2VkLCBvcHRpb25zLCBwYXJzZSwgcGFyc2VJbmxpbmUsIHBhcnNlciwgc2V0T3B0aW9ucywgdXNlLCB3YWxrVG9rZW5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXJrZWQuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9nZXREZWZhdWx0cyIsImFzeW5jIiwiYnJlYWtzIiwiZXh0ZW5zaW9ucyIsImdmbSIsImhvb2tzIiwicGVkYW50aWMiLCJyZW5kZXJlciIsInNpbGVudCIsInRva2VuaXplciIsIndhbGtUb2tlbnMiLCJfZGVmYXVsdHMiLCJjaGFuZ2VEZWZhdWx0cyIsIm5ld0RlZmF1bHRzIiwibm9vcFRlc3QiLCJleGVjIiwiZWRpdCIsInJlZ2V4Iiwib3B0Iiwic291cmNlIiwib2JqIiwicmVwbGFjZSIsIm5hbWUiLCJ2YWwiLCJ2YWxTb3VyY2UiLCJvdGhlciIsImNhcmV0IiwiZ2V0UmVnZXgiLCJSZWdFeHAiLCJjb2RlUmVtb3ZlSW5kZW50Iiwib3V0cHV0TGlua1JlcGxhY2UiLCJpbmRlbnRDb2RlQ29tcGVuc2F0aW9uIiwiYmVnaW5uaW5nU3BhY2UiLCJlbmRpbmdIYXNoIiwic3RhcnRpbmdTcGFjZUNoYXIiLCJlbmRpbmdTcGFjZUNoYXIiLCJub25TcGFjZUNoYXIiLCJuZXdMaW5lQ2hhckdsb2JhbCIsInRhYkNoYXJHbG9iYWwiLCJtdWx0aXBsZVNwYWNlR2xvYmFsIiwiYmxhbmtMaW5lIiwiZG91YmxlQmxhbmtMaW5lIiwiYmxvY2txdW90ZVN0YXJ0IiwiYmxvY2txdW90ZVNldGV4dFJlcGxhY2UiLCJibG9ja3F1b3RlU2V0ZXh0UmVwbGFjZTIiLCJsaXN0UmVwbGFjZVRhYnMiLCJsaXN0UmVwbGFjZU5lc3RpbmciLCJsaXN0SXNUYXNrIiwibGlzdFJlcGxhY2VUYXNrIiwiYW55TGluZSIsImhyZWZCcmFja2V0cyIsInRhYmxlRGVsaW1pdGVyIiwidGFibGVBbGlnbkNoYXJzIiwidGFibGVSb3dCbGFua0xpbmUiLCJ0YWJsZUFsaWduUmlnaHQiLCJ0YWJsZUFsaWduQ2VudGVyIiwidGFibGVBbGlnbkxlZnQiLCJzdGFydEFUYWciLCJlbmRBVGFnIiwic3RhcnRQcmVTY3JpcHRUYWciLCJlbmRQcmVTY3JpcHRUYWciLCJzdGFydEFuZ2xlQnJhY2tldCIsImVuZEFuZ2xlQnJhY2tldCIsInBlZGFudGljSHJlZlRpdGxlIiwidW5pY29kZUFscGhhTnVtZXJpYyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwidW5lc2NhcGVUZXN0IiwicGVyY2VudERlY29kZSIsImZpbmRQaXBlIiwic3BsaXRQaXBlIiwic2xhc2hQaXBlIiwiY2FycmlhZ2VSZXR1cm4iLCJzcGFjZUxpbmUiLCJub3RTcGFjZVN0YXJ0IiwiZW5kaW5nTmV3bGluZSIsImxpc3RJdGVtUmVnZXgiLCJidWxsIiwibmV4dEJ1bGxldFJlZ2V4IiwiaW5kZW50IiwiTWF0aCIsIm1pbiIsImhyUmVnZXgiLCJmZW5jZXNCZWdpblJlZ2V4IiwiaGVhZGluZ0JlZ2luUmVnZXgiLCJodG1sQmVnaW5SZWdleCIsIm5ld2xpbmUiLCJibG9ja0NvZGUiLCJmZW5jZXMiLCJociIsImhlYWRpbmciLCJidWxsZXQiLCJsaGVhZGluZ0NvcmUiLCJsaGVhZGluZyIsImxoZWFkaW5nR2ZtIiwiX3BhcmFncmFwaCIsImJsb2NrVGV4dCIsIl9ibG9ja0xhYmVsIiwiZGVmIiwibGlzdCIsIl90YWciLCJfY29tbWVudCIsImh0bWwiLCJwYXJhZ3JhcGgiLCJibG9ja3F1b3RlIiwiYmxvY2tOb3JtYWwiLCJjb2RlIiwidGFibGUiLCJ0ZXh0IiwiZ2ZtVGFibGUiLCJibG9ja0dmbSIsImJsb2NrUGVkYW50aWMiLCJlc2NhcGUkMSIsImlubGluZUNvZGUiLCJiciIsImlubGluZVRleHQiLCJfcHVuY3R1YXRpb24iLCJfcHVuY3R1YXRpb25PclNwYWNlIiwiX25vdFB1bmN0dWF0aW9uT3JTcGFjZSIsInB1bmN0dWF0aW9uIiwiX3B1bmN0dWF0aW9uR2ZtU3Ryb25nRW0iLCJfcHVuY3R1YXRpb25PclNwYWNlR2ZtU3Ryb25nRW0iLCJfbm90UHVuY3R1YXRpb25PclNwYWNlR2ZtU3Ryb25nRW0iLCJibG9ja1NraXAiLCJlbVN0cm9uZ0xEZWxpbUNvcmUiLCJlbVN0cm9uZ0xEZWxpbSIsImVtU3Ryb25nTERlbGltR2ZtIiwiZW1TdHJvbmdSRGVsaW1Bc3RDb3JlIiwiZW1TdHJvbmdSRGVsaW1Bc3QiLCJlbVN0cm9uZ1JEZWxpbUFzdEdmbSIsImVtU3Ryb25nUkRlbGltVW5kIiwiYW55UHVuY3R1YXRpb24iLCJhdXRvbGluayIsIl9pbmxpbmVDb21tZW50IiwidGFnIiwiX2lubGluZUxhYmVsIiwibGluayIsInJlZmxpbmsiLCJub2xpbmsiLCJyZWZsaW5rU2VhcmNoIiwiaW5saW5lTm9ybWFsIiwiX2JhY2twZWRhbCIsImRlbCIsImVzY2FwZSIsInVybCIsImlubGluZVBlZGFudGljIiwiaW5saW5lR2ZtIiwiaW5saW5lQnJlYWtzIiwiYmxvY2siLCJub3JtYWwiLCJpbmxpbmUiLCJlc2NhcGVSZXBsYWNlbWVudHMiLCJnZXRFc2NhcGVSZXBsYWNlbWVudCIsImNoIiwiZW5jb2RlIiwidGVzdCIsImNsZWFuVXJsIiwiaHJlZiIsImVuY29kZVVSSSIsInNwbGl0Q2VsbHMiLCJ0YWJsZVJvdyIsImNvdW50Iiwicm93IiwibWF0Y2giLCJvZmZzZXQiLCJzdHIiLCJlc2NhcGVkIiwiY3VyciIsImNlbGxzIiwic3BsaXQiLCJpIiwidHJpbSIsInNoaWZ0IiwibGVuZ3RoIiwiYXQiLCJwb3AiLCJzcGxpY2UiLCJwdXNoIiwicnRyaW0iLCJjIiwiaW52ZXJ0IiwibCIsInN1ZmZMZW4iLCJjdXJyQ2hhciIsImNoYXJBdCIsInNsaWNlIiwiZmluZENsb3NpbmdCcmFja2V0IiwiYiIsImluZGV4T2YiLCJsZXZlbCIsIm91dHB1dExpbmsiLCJjYXAiLCJyYXciLCJsZXhlciIsInJ1bGVzIiwidGl0bGUiLCJzdGF0ZSIsImluTGluayIsInRva2VuIiwidHlwZSIsInRva2VucyIsImlubGluZVRva2VucyIsIm1hdGNoSW5kZW50VG9Db2RlIiwiaW5kZW50VG9Db2RlIiwibWFwIiwibm9kZSIsIm1hdGNoSW5kZW50SW5Ob2RlIiwiaW5kZW50SW5Ob2RlIiwiam9pbiIsIl9Ub2tlbml6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzcGFjZSIsInNyYyIsImNvZGVCbG9ja1N0eWxlIiwibGFuZyIsInRyaW1tZWQiLCJkZXB0aCIsImxpbmVzIiwiaW5CbG9ja3F1b3RlIiwiY3VycmVudExpbmVzIiwiY3VycmVudFJhdyIsImN1cnJlbnRUZXh0IiwidG9wIiwiYmxvY2tUb2tlbnMiLCJsYXN0VG9rZW4iLCJvbGRUb2tlbiIsIm5ld1RleHQiLCJuZXdUb2tlbiIsInN1YnN0cmluZyIsImlzb3JkZXJlZCIsIm9yZGVyZWQiLCJzdGFydCIsImxvb3NlIiwiaXRlbXMiLCJpdGVtUmVnZXgiLCJlbmRzV2l0aEJsYW5rTGluZSIsImVuZEVhcmx5IiwiaXRlbUNvbnRlbnRzIiwibGluZSIsInQiLCJyZXBlYXQiLCJuZXh0TGluZSIsInRyaW1TdGFydCIsInNlYXJjaCIsInJhd0xpbmUiLCJuZXh0TGluZVdpdGhvdXRUYWJzIiwiaXN0YXNrIiwiaXNjaGVja2VkIiwidGFzayIsImNoZWNrZWQiLCJsYXN0SXRlbSIsInRyaW1FbmQiLCJzcGFjZXJzIiwiZmlsdGVyIiwiaGFzTXVsdGlwbGVMaW5lQnJlYWtzIiwic29tZSIsInByZSIsInRvTG93ZXJDYXNlIiwiaGVhZGVycyIsImFsaWducyIsInJvd3MiLCJpdGVtIiwiaGVhZGVyIiwiYWxpZ24iLCJjZWxsIiwiaW5SYXdCbG9jayIsInRyaW1tZWRVcmwiLCJydHJpbVNsYXNoIiwibGFzdFBhcmVuSW5kZXgiLCJsaW5rTGVuIiwibGlua3MiLCJsaW5rU3RyaW5nIiwiZW1TdHJvbmciLCJtYXNrZWRTcmMiLCJwcmV2Q2hhciIsIm5leHRDaGFyIiwibExlbmd0aCIsInJEZWxpbSIsInJMZW5ndGgiLCJkZWxpbVRvdGFsIiwibWlkRGVsaW1Ub3RhbCIsImVuZFJlZyIsImxhc3RJbmRleCIsImxhc3RDaGFyTGVuZ3RoIiwiaW5kZXgiLCJjb2Rlc3BhbiIsImhhc05vblNwYWNlQ2hhcnMiLCJoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyIsInByZXZDYXBaZXJvIiwiX0xleGVyIiwiT2JqZWN0IiwiY3JlYXRlIiwiaW5saW5lUXVldWUiLCJsZXgiLCJsZXhJbmxpbmUiLCJuZXh0IiwibGFzdFBhcmFncmFwaENsaXBwZWQiLCJleHRUb2tlbml6ZXIiLCJjYWxsIiwidW5kZWZpbmVkIiwiY3V0U3JjIiwic3RhcnRCbG9jayIsInN0YXJ0SW5kZXgiLCJJbmZpbml0eSIsInRlbXBTcmMiLCJ0ZW1wU3RhcnQiLCJmb3JFYWNoIiwiZ2V0U3RhcnRJbmRleCIsImVyck1zZyIsImNoYXJDb2RlQXQiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsImtleXMiLCJpbmNsdWRlcyIsImxhc3RJbmRleE9mIiwia2VlcFByZXZDaGFyIiwic3RhcnRJbmxpbmUiLCJfUmVuZGVyZXIiLCJsYW5nU3RyaW5nIiwiYm9keSIsInBhcnNlciIsInBhcnNlIiwicGFyc2VJbmxpbmUiLCJqIiwibGlzdGl0ZW0iLCJzdGFydEF0dHIiLCJpdGVtQm9keSIsImNoZWNrYm94IiwidW5zaGlmdCIsInRhYmxlY2VsbCIsInRhYmxlcm93IiwiayIsImNvbnRlbnQiLCJzdHJvbmciLCJlbSIsImNsZWFuSHJlZiIsIm91dCIsImltYWdlIiwiX1RleHRSZW5kZXJlciIsIl9QYXJzZXIiLCJ0ZXh0UmVuZGVyZXIiLCJhbnlUb2tlbiIsInJlbmRlcmVycyIsImdlbmVyaWNUb2tlbiIsInJldCIsInRleHRUb2tlbiIsIl9Ib29rcyIsInBhc3NUaHJvdWdoSG9va3MiLCJTZXQiLCJwcmVwcm9jZXNzIiwibWFya2Rvd24iLCJwb3N0cHJvY2VzcyIsInByb2Nlc3NBbGxUb2tlbnMiLCJwcm92aWRlTGV4ZXIiLCJwcm92aWRlUGFyc2VyIiwiTWFya2VkIiwiYXJncyIsImRlZmF1bHRzIiwic2V0T3B0aW9ucyIsInBhcnNlTWFya2Rvd24iLCJQYXJzZXIiLCJSZW5kZXJlciIsIlRleHRSZW5kZXJlciIsIkxleGVyIiwiVG9rZW5pemVyIiwiSG9va3MiLCJ1c2UiLCJjYWxsYmFjayIsInZhbHVlcyIsImNvbmNhdCIsInRhYmxlVG9rZW4iLCJsaXN0VG9rZW4iLCJjaGlsZFRva2VucyIsImZsYXQiLCJwYWNrIiwib3B0cyIsImV4dCIsInByZXZSZW5kZXJlciIsImFwcGx5IiwiZXh0TGV2ZWwiLCJwcm9wIiwicmVuZGVyZXJQcm9wIiwicmVuZGVyZXJGdW5jIiwidG9rZW5pemVyUHJvcCIsInRva2VuaXplckZ1bmMiLCJwcmV2VG9rZW5pemVyIiwiaG9va3NQcm9wIiwiaG9va3NGdW5jIiwicHJldkhvb2siLCJoYXMiLCJhcmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJwYWNrV2Fsa3Rva2VucyIsImJsb2NrVHlwZSIsIm9yaWdPcHQiLCJ0aHJvd0Vycm9yIiwib25FcnJvciIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiYWxsIiwiY2F0Y2giLCJlIiwibWVzc2FnZSIsIm1zZyIsInJlamVjdCIsIm1hcmtlZEluc3RhbmNlIiwibWFya2VkIiwiZ2V0RGVmYXVsdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/marked/lib/marked.esm.js\n");

/***/ })

};
;